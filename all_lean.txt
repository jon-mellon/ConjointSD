

File:  ConjointSD.lean
import ConjointSD.PredictedSD
import ConjointSD.SDDecompositionFromConjoint
import ConjointSD.VarianceDecompositionFromBlocks
import ConjointSD.ConjointIdentification
import ConjointSD.Transport
import ConjointSD.EstimatedG
import ConjointSD.FinalCleanEstimate
import ConjointSD.SampleSplitting
import ConjointSD.ModelBridge
import ConjointSD.PopulationBridge
import ConjointSD.OracleSDConsistency
import ConjointSD.SequentialConsistency
import ConjointSD.DecompositionSequentialConsistency
import ConjointSD.PaperWrappers
import ConjointSD.TrueBlockEstimand
import ConjointSD.TermModelBlocks
import ConjointSD.RegressionConsistencyBridge
import ConjointSD.FunctionalContinuityAssumptions
import ConjointSD.PaperCoreEstimand
import ConjointSD.WellSpecifiedFromNoInteractions

File:  ConjointSD/ConjointIdentification.lean
/-
ConjointSD/ConjointIdentification.lean
-/


import Mathlib

open Filter MeasureTheory ProbabilityTheory
open scoped BigOperators

noncomputable section
namespace ConjointSD

variable {Ω : Type*} [MeasurableSpace Ω]
variable (μ : Measure Ω) [IsProbabilityMeasure μ]
variable {Attr : Type*}

/-- Event that the shown profile equals `x`. -/
def eventX (X : Ω → Attr) (x : Attr) : Set Ω := {ω | X ω = x}

/-- Conditional mean on an event `s`: (∫ Z d(μ.restrict s)) / (μ s).toReal. -/
def condMean (μ : Measure Ω) (Z : Ω → ℝ) (s : Set Ω) : ℝ :=
  (∫ ω, Z ω ∂ (μ.restrict s)) / (μ s).toReal

/-- Mean of a potential outcome under profile `x`. -/
def potMean (μ : Measure Ω) (Y : Attr → Ω → ℝ) (x : Attr) : ℝ :=
  ∫ ω, Y x ω ∂μ

/-- AMCE between profiles `x` and `x'`. -/
def amce (μ : Measure Ω) (Y : Attr → Ω → ℝ) (x x' : Attr) : ℝ :=
  potMean (μ := μ) Y x' - potMean (μ := μ) Y x

/--
Identification assumptions for the single-profile abstraction.

`rand` is written in a “factorization” form in ℝ (via `.toReal`) so we can avoid
conditional-expectation infrastructure: it directly implies that conditioning on `{X=x0}`
does not change the mean of `Y x`.

Measurability of `Yobs` and each `Y x` is included to make the key AE-restrict step compile.
-/
structure ConjointIdAssumptions
    (X : Ω → Attr) (Y : Attr → Ω → ℝ) (Yobs : Ω → ℝ) : Prop where
  measYobs : Measurable Yobs
  measY : ∀ x, Measurable (Y x)
  consistency : ∀ ω, Yobs ω = Y (X ω) ω
  positivity : ∀ x, μ (eventX (X := X) x) ≠ 0
  rand :
    ∀ x x0,
      (∫ ω, Y x ω ∂ (μ.restrict (eventX (X := X) x0)))
        = (μ (eventX (X := X) x0)).toReal * (∫ ω, Y x ω ∂μ)

variable {μ}

/-- `(μ s).toReal ≠ 0` from `μ s ≠ 0` under a finite measure. -/
lemma toReal_ne_zero_of_ne_zero (μ : Measure Ω) [IsFiniteMeasure μ]
    (s : Set Ω) (h : μ s ≠ 0) : (μ s).toReal ≠ 0 := by
  refine ENNReal.toReal_ne_zero.2 ?_
  refine ⟨h, ?_⟩
  simpa using (measure_ne_top μ s)

/-- If the factorization holds, the event-conditional mean equals the unconditional mean. -/
theorem condMean_eq_potMean_of_rand
    (X : Ω → Attr) (Y : Attr → Ω → ℝ)
    (x x0 : Attr)
    (hpos : μ (eventX (X := X) x0) ≠ 0)
    (hrand :
      (∫ ω, Y x ω ∂ (μ.restrict (eventX (X := X) x0)))
        = (μ (eventX (X := X) x0)).toReal * (∫ ω, Y x ω ∂μ)) :
    condMean (μ := μ) (Y x) (eventX (X := X) x0) = potMean (μ := μ) Y x := by
  letI : IsFiniteMeasure μ := by infer_instance
  have hposR : (μ (eventX (X := X) x0)).toReal ≠ 0 :=
    toReal_ne_zero_of_ne_zero (μ := μ) (eventX (X := X) x0) hpos
  unfold condMean potMean
  -- numerator is `(μ s).toReal * (∫ Y)`; divide by `(μ s).toReal` to get `∫ Y`.
  simp [hrand, div_eq_mul_inv, hposR, mul_assoc, mul_left_comm, mul_comm]

/--
Consistency implies: on the event `{X=x0}`, `Yobs = Y x0` holds a.e. under `μ.restrict`.

Important: in mathlib v4.26, `ae_restrict_iff` expects measurability of the *predicate-set*
`{ω | p ω}`, not measurability of the event `s`. So we prove measurability of
`{ω | Yobs ω = Y x0 ω}` from measurability of `Yobs` and `Y x0`.
-/
theorem ae_restrict_consistency
    (X : Ω → Attr) (Y : Attr → Ω → ℝ) (Yobs : Ω → ℝ)
    (x0 : Attr)
    (hmeasYobs : Measurable Yobs)
    (hmeasYx0 : Measurable (Y x0))
    (hcons : ∀ ω, Yobs ω = Y (X ω) ω) :
    (∀ᵐ ω ∂ (μ.restrict (eventX (X := X) x0)), Yobs ω = Y x0 ω) := by
  -- Measurable predicate-set needed by `ae_restrict_iff`.
  have hpred : MeasurableSet {ω : Ω | Yobs ω = Y x0 ω} := by
    have hsub : Measurable (fun ω : Ω => Yobs ω - Y x0 ω) :=
      hmeasYobs.sub hmeasYx0
    have h0 : MeasurableSet ({0} : Set ℝ) := by
      simpa using (measurableSet_singleton (0 : ℝ))
    have hset :
        {ω : Ω | Yobs ω = Y x0 ω}
          = (fun ω : Ω => Yobs ω - Y x0 ω) ⁻¹' ({0} : Set ℝ) := by
      ext ω
      simp [sub_eq_zero]
    simpa [hset] using h0.preimage hsub

  -- Now use `ae_restrict_iff` in the direction: (ae on μ with implication) -> (ae on μ.restrict).
  refine (ae_restrict_iff (μ := μ) (s := eventX (X := X) x0)
            (p := fun ω => Yobs ω = Y x0 ω) hpred).2 ?_
  refine ae_of_all _ ?_
  intro ω hω
  -- hω : ω ∈ {ω | X ω = x0}  i.e. X ω = x0
  have hx : X ω = x0 := hω
  simpa [hcons ω, hx]

/-- Identification: observed conditional mean among `X=x0` equals `E[Y(x0)]`. -/
theorem identified_potMean_from_condMean
    (X : Ω → Attr) (Y : Attr → Ω → ℝ) (Yobs : Ω → ℝ)
    (h : ConjointIdAssumptions (μ := μ) X Y Yobs)
    (x0 : Attr) :
    condMean (μ := μ) Yobs (eventX (X := X) x0) = potMean (μ := μ) Y x0 := by
  have hae :
      (∀ᵐ ω ∂ (μ.restrict (eventX (X := X) x0)), Yobs ω = Y x0 ω) :=
    ae_restrict_consistency (μ := μ) (X := X) (Y := Y) (Yobs := Yobs)
      x0 (h.measYobs) (h.measY x0) (h.consistency)

  have hint :
      (∫ ω, Yobs ω ∂ (μ.restrict (eventX (X := X) x0)))
        =
      (∫ ω, Y x0 ω ∂ (μ.restrict (eventX (X := X) x0))) := by
    exact integral_congr_ae hae

  have hpos : μ (eventX (X := X) x0) ≠ 0 := h.positivity x0
  have hrand :
      (∫ ω, Y x0 ω ∂ (μ.restrict (eventX (X := X) x0)))
        =
      (μ (eventX (X := X) x0)).toReal * (∫ ω, Y x0 ω ∂μ) :=
    h.rand x0 x0

  calc
    condMean (μ := μ) Yobs (eventX (X := X) x0)
        = (∫ ω, Y x0 ω ∂ (μ.restrict (eventX (X := X) x0)))
            / (μ (eventX (X := X) x0)).toReal := by
              simp [condMean, hint]
    _   = potMean (μ := μ) Y x0 := by
              exact condMean_eq_potMean_of_rand (μ := μ) (X := X) (Y := Y) x0 x0 hpos hrand

/-- Identification of AMCE as a difference of observed conditional means. -/
theorem identified_amce_from_condMeans
    (X : Ω → Attr) (Y : Attr → Ω → ℝ) (Yobs : Ω → ℝ)
    (h : ConjointIdAssumptions (μ := μ) X Y Yobs)
    (x x' : Attr) :
    (condMean (μ := μ) Yobs (eventX (X := X) x')
      - condMean (μ := μ) Yobs (eventX (X := X) x))
      =
    amce (μ := μ) Y x x' := by
  unfold amce
  have hx' :
      condMean (μ := μ) Yobs (eventX (X := X) x') = potMean (μ := μ) Y x' :=
    identified_potMean_from_condMean (μ := μ) (X := X) (Y := Y) (Yobs := Yobs) h x'
  have hx :
      condMean (μ := μ) Yobs (eventX (X := X) x) = potMean (μ := μ) Y x :=
    identified_potMean_from_condMean (μ := μ) (X := X) (Y := Y) (Yobs := Yobs) h x
  simp [hx', hx]

/-!
## Identified score function (design-mean) equals causal score function (potential mean)
-/

/-- Design-identified score: observed conditional mean among units with `X = x`. -/
def gExp (μ : Measure Ω) (X : Ω → Attr) (Yobs : Ω → ℝ) : Attr → ℝ :=
  fun x => condMean (μ := μ) Yobs (eventX (X := X) x)

/-- Causal score: potential-outcome mean under profile `x`. -/
def gPot (μ : Measure Ω) (Y : Attr → Ω → ℝ) : Attr → ℝ :=
  fun x => potMean (μ := μ) Y x

/--
Under the conjoint identification assumptions, the observed conditional-mean score function
equals the causal potential-mean score function (pointwise, hence as functions).
-/
theorem gExp_eq_gPot
    (X : Ω → Attr) (Y : Attr → Ω → ℝ) (Yobs : Ω → ℝ)
    (h : ConjointIdAssumptions (μ := μ) X Y Yobs) :
    gExp (μ := μ) (X := X) (Yobs := Yobs) = gPot (μ := μ) (Y := Y) := by
  funext x
  simpa [gExp, gPot] using
    identified_potMean_from_condMean (μ := μ) (X := X) (Y := Y) (Yobs := Yobs) h x

end ConjointSD

File:  ConjointSD/DecompositionSequentialConsistency.lean
/-
ConjointSD/DecompositionSequentialConsistency.lean

Route 1 (assumption-bundling) sequential consistency for an SD decomposition.

Provides:
1) Per-block sequential consistency with a single M working for all b : B (finite).
2) Total-score sequential consistency for the summed score.
-/

import Mathlib
import ConjointSD.SequentialConsistency
import ConjointSD.SampleSplitting
import ConjointSD.EstimatedG
import ConjointSD.Transport

open Filter MeasureTheory ProbabilityTheory
open scoped Topology BigOperators

noncomputable section
namespace ConjointSD

section

variable {Ω : Type*} [MeasurableSpace Ω]
variable {Attr : Type*} [MeasurableSpace Attr]
variable {Θ : Type*}
variable {B : Type*} [Fintype B]

/-- A block score family parameterized by θ. -/
def gBlock (gB : B → Θ → Attr → ℝ) (b : B) : Θ → Attr → ℝ :=
  fun θ a => gB b θ a

/-- Total score (sum over blocks) parameterized by θ. -/
def gTotalΘ (gB : B → Θ → Attr → ℝ) : Θ → Attr → ℝ :=
  fun θ a => ∑ b : B, gB b θ a

/-- Per-block sequential consistency with a single `M` working for all `b : B` (finite B). -/
theorem sequential_consistency_blocks_ae
    (μ : Measure Ω) [IsProbabilityMeasure μ]
    (A : ℕ → Ω → Attr)
    (ν : Measure Attr) [IsProbabilityMeasure ν]
    (hLaw : Measure.map (A 0) μ = ν)
    (gB : B → Θ → Attr → ℝ) (θ0 : Θ) (θhat : ℕ → Θ)
    (hSplit : ∀ m b,
      SplitEvalAssumptions (μ := μ) (A := A) (g := gBlock (gB := gB) b) (θhat := θhat) m)
    (hG : ∀ b,
      GEstimationAssumptions (ν := ν) (g := gBlock (gB := gB) b) (θ0 := θ0) (θhat := θhat))
    (ε : ℝ) (hε : 0 < ε) :
    ∃ M : ℕ,
      ∀ m ≥ M,
        ∀ b : B,
          (∀ᵐ ω ∂μ,
            ∀ᶠ n : ℕ in atTop,
              totalErr μ A ν (gBlock (gB := gB) b) θ0 θhat m n ω < ε) := by
  classical

  have hEach :
      ∀ b : B,
        ∃ Mb : ℕ,
          ∀ m ≥ Mb,
            (∀ᵐ ω ∂μ,
              ∀ᶠ n : ℕ in atTop,
                totalErr μ A ν (gBlock (gB := gB) b) θ0 θhat m n ω < ε) := by
    intro b
    simpa [gBlock] using
      (sequential_consistency_ae
        (μ := μ) (A := A) (ν := ν) (hLaw := hLaw)
        (g := gBlock (gB := gB) b) (θ0 := θ0) (θhat := θhat)
        (hSplit := fun m => hSplit m b)
        (hG := hG b)
        (ε := ε) (hε := hε))

  choose Mb hMb using hEach

  let M : ℕ := (Finset.univ : Finset B).sup Mb

  refine ⟨M, ?_⟩
  intro m hm b

  have hMb_le_M : Mb b ≤ M := by
    have hb : b ∈ (Finset.univ : Finset B) := by simp
    exact Finset.le_sup hb

  have hMb_le_m : Mb b ≤ m := le_trans hMb_le_M hm
  -- Now apply the block-specific conclusion.
  exact hMb b m hMb_le_m

/-- Total-score sequential consistency for the summed score `gTotalΘ`. -/
theorem sequential_consistency_total_ae
    (μ : Measure Ω) [IsProbabilityMeasure μ]
    (A : ℕ → Ω → Attr)
    (ν : Measure Attr) [IsProbabilityMeasure ν]
    (hLaw : Measure.map (A 0) μ = ν)
    (gB : B → Θ → Attr → ℝ) (θ0 : Θ) (θhat : ℕ → Θ)
    (hSplitTotal :
      ∀ m,
        SplitEvalAssumptions (μ := μ) (A := A) (g := gTotalΘ (gB := gB)) (θhat := θhat) m)
    (hGTotal :
      GEstimationAssumptions (ν := ν) (g := gTotalΘ (gB := gB)) (θ0 := θ0) (θhat := θhat))
    (ε : ℝ) (hε : 0 < ε) :
    ∃ M : ℕ,
      ∀ m ≥ M,
        (∀ᵐ ω ∂μ,
          ∀ᶠ n : ℕ in atTop,
            totalErr μ A ν (gTotalΘ (gB := gB)) θ0 θhat m n ω < ε) := by
  simpa [gTotalΘ] using
    (sequential_consistency_ae
      (μ := μ) (A := A) (ν := ν) (hLaw := hLaw)
      (g := gTotalΘ (gB := gB)) (θ0 := θ0) (θhat := θhat)
      (hSplit := hSplitTotal)
      (hG := hGTotal)
      (ε := ε) (hε := hε))

end

end ConjointSD

File:  ConjointSD/Defs.lean
-- ConjointSD/Defs.lean
import Mathlib

open scoped BigOperators
open Filter MeasureTheory ProbabilityTheory

noncomputable section
namespace ConjointSD

/-!
Core definitions shared across the project.

This file is intentionally definition-only (no heavy theorems), so other modules can
import it without pulling in lots of dependencies.
-/

section IdentificationBasics

variable {Ω : Type*} [MeasurableSpace Ω]
variable (μ : Measure Ω) [IsProbabilityMeasure μ]
variable {Attr : Type*}

/-- Event that the shown profile equals `x`. -/
def eventX (X : Ω → Attr) (x : Attr) : Set Ω := {ω | X ω = x}

/-- Conditional mean on an event `s`: `(∫ Z d(μ.restrict s)) / (μ s).toReal`. -/
def condMean (μ : Measure Ω) (Z : Ω → ℝ) (s : Set Ω) : ℝ :=
  (∫ ω, Z ω ∂ (μ.restrict s)) / (μ s).toReal

/-- Mean of a potential outcome under profile `x`. -/
def potMean (μ : Measure Ω) (Y : Attr → Ω → ℝ) (x : Attr) : ℝ :=
  ∫ ω, Y x ω ∂μ

/-- AMCE between profiles `x` and `x'`. -/
def amce (μ : Measure Ω) (Y : Attr → Ω → ℝ) (x x' : Attr) : ℝ :=
  potMean (μ := μ) Y x' - potMean (μ := μ) Y x

end IdentificationBasics

section AdditiveDecomposition

variable {Attr : Type*}
variable {B : Type*} [Fintype B]

/-- Total additive score. -/
def gTotal (g : B → Attr → ℝ) : Attr → ℝ :=
  fun a => ∑ b, g b a

end AdditiveDecomposition

section VarianceDefs

variable {Ω : Type*} [MeasurableSpace Ω]
variable (μ : Measure Ω) [IsProbabilityMeasure μ]

/-- Raw covariance: `E[XY] - E[X]E[Y]`. -/
def covRaw (X Y : Ω → ℝ) : ℝ :=
  (∫ ω, X ω * Y ω ∂μ) - (∫ ω, X ω ∂μ) * (∫ ω, Y ω ∂μ)

/-- Variance proxy: `E[X^2] - (E[X])^2`. -/
def varProxy (X : Ω → ℝ) : ℝ :=
  (∫ ω, (X ω) ^ 2 ∂μ) - (∫ ω, X ω ∂μ) ^ 2

end VarianceDefs

end ConjointSD

File:  ConjointSD/DeriveGEstimationAssumptions.lean
/-
ConjointSD/DeriveGEstimationAssumptions.lean

Utilities to eliminate the Route-1 assumption
  hG : ∀ b, GEstimationAssumptions …
from paper-facing theorems, by deriving it from:
  (1) θhat → θ0
  (2) continuity-at-θ0 of the population functionals

This file compiles independently and is meant to be imported by your paper wrapper file
(previously `FinalTheorems.lean`).
-/

import ConjointSD.RegressionConsistencyBridge

open Filter MeasureTheory
open scoped Topology

noncomputable section
namespace ConjointSD

/-- Route-2: derive `GEstimationAssumptions` (single score) from `θhat → θ0` and functional continuity. -/
theorem derive_hG
    {Attr Θ : Type*} [MeasurableSpace Attr] [TopologicalSpace Θ]
    (ν : Measure Attr) [IsProbabilityMeasure ν]
    (g : Θ → Attr → ℝ) (θ0 : Θ) (θhat : ℕ → Θ)
    (hθ : Tendsto θhat atTop (nhds θ0))
    (hcont : FunctionalContinuityAssumptions (ν := ν) g θ0) :
    GEstimationAssumptions (ν := ν) g θ0 θhat :=
  GEstimationAssumptions_of_theta_tendsto
    (ν := ν) (g := g) (θ0 := θ0) (θhat := θhat) hθ hcont

/-- Route-2: derive `∀ b, GEstimationAssumptions …` for block scores from `θhat → θ0` and block continuity. -/
theorem derive_hG_blocks
    {Attr Θ B : Type*} [MeasurableSpace Attr] [TopologicalSpace Θ] [Fintype B]
    (ν : Measure Attr) [IsProbabilityMeasure ν]
    (gB : B → Θ → Attr → ℝ) (θ0 : Θ) (θhat : ℕ → Θ)
    (hθ : Tendsto θhat atTop (nhds θ0))
    (hcont : BlockFunctionalContinuityAssumptions (ν := ν) gB θ0) :
    ∀ b : B, GEstimationAssumptions (ν := ν) (blockScoreΘ (gB := gB) b) θ0 θhat :=
  block_GEstimationAssumptions_of_theta_tendsto
    (ν := ν) (gB := gB) (θ0 := θ0) (θhat := θhat) hθ hcont

end ConjointSD

File:  ConjointSD/EstimatedG.lean
/-
ConjointSD/EstimatedG.lean

Step 3: handle that g depends on estimated parameters.

We assume the population moments on attributes (popMeanAttr/popM2Attr/popVarAttr/popSDAttr)
are already defined in ConjointSD.Transport. We package assumptions about convergence of
population *mean* and *second moment* under ν when we replace oracle `g θ0` by `g (θhat n)`,
and we *derive* variance and SD convergence from those.
-/

import ConjointSD.Transport
import Mathlib.Topology.Basic

namespace ConjointSD

noncomputable section

universe u v

open scoped Topology
open Filter
open MeasureTheory

variable {Attr : Type u} [MeasurableSpace Attr]
variable {Θ : Type v}

/-- Plug-in (estimated) status function on attributes. -/
def gHat (g : Θ → Attr → ℝ) (θhat : ℕ → Θ) (n : ℕ) : Attr → ℝ :=
  fun a => g (θhat n) a

/--
Assumptions ensuring replacing oracle `g θ0` with estimated `g (θhat n)` does not change
target population moments (under ν) in the limit.

Minimal version: assume convergence of mean and second moment; derive var and sd.
-/
structure GEstimationAssumptions
    (ν : Measure Attr) [IsProbabilityMeasure ν]
    (g : Θ → Attr → ℝ) (θ0 : Θ) (θhat : ℕ → Θ) : Prop where
  mean_tendsto :
      Tendsto
        (fun n => popMeanAttr ν (gHat g θhat n))
        atTop
        (nhds (popMeanAttr ν (g θ0)))

  m2_tendsto :
      Tendsto
        (fun n => popM2Attr ν (gHat g θhat n))
        atTop
        (nhds (popM2Attr ν (g θ0)))

theorem popMeanAttr_tendsto_of_GEstimationAssumptions
    {ν : Measure Attr} [IsProbabilityMeasure ν]
    {g : Θ → Attr → ℝ} {θ0 : Θ} {θhat : ℕ → Θ}
    (h : GEstimationAssumptions (ν := ν) g θ0 θhat) :
    Tendsto
      (fun n => popMeanAttr ν (gHat g θhat n))
      atTop
      (nhds (popMeanAttr ν (g θ0))) :=
  h.mean_tendsto

theorem popM2Attr_tendsto_of_GEstimationAssumptions
    {ν : Measure Attr} [IsProbabilityMeasure ν]
    {g : Θ → Attr → ℝ} {θ0 : Θ} {θhat : ℕ → Θ}
    (h : GEstimationAssumptions (ν := ν) g θ0 θhat) :
    Tendsto
      (fun n => popM2Attr ν (gHat g θhat n))
      atTop
      (nhds (popM2Attr ν (g θ0))) :=
  h.m2_tendsto

/-- Derived: population variance convergence under ν for the plug-in score. -/
theorem popVarAttr_tendsto_of_GEstimationAssumptions
    {ν : Measure Attr} [IsProbabilityMeasure ν]
    {g : Θ → Attr → ℝ} {θ0 : Θ} {θhat : ℕ → Θ}
    (h : GEstimationAssumptions (ν := ν) g θ0 θhat) :
    Tendsto
      (fun n => popVarAttr ν (gHat g θhat n))
      atTop
      (nhds (popVarAttr ν (g θ0))) := by
  have hmean := h.mean_tendsto
  have hm2 := h.m2_tendsto

  have hmean2 :
      Tendsto
        (fun n => (popMeanAttr ν (gHat g θhat n)) ^ 2)
        atTop
        (nhds ((popMeanAttr ν (g θ0)) ^ 2)) := by
    simpa [pow_two] using (hmean.mul hmean)

  have hvar :
      Tendsto
        (fun n => popM2Attr ν (gHat g θhat n) - (popMeanAttr ν (gHat g θhat n)) ^ 2)
        atTop
        (nhds (popM2Attr ν (g θ0) - (popMeanAttr ν (g θ0)) ^ 2)) :=
    hm2.sub hmean2

  simpa [popVarAttr] using hvar

/-- Derived: population SD convergence under ν for the plug-in score. -/
theorem popSDAttr_tendsto_of_GEstimationAssumptions
    {ν : Measure Attr} [IsProbabilityMeasure ν]
    {g : Θ → Attr → ℝ} {θ0 : Θ} {θhat : ℕ → Θ}
    (h : GEstimationAssumptions (ν := ν) g θ0 θhat) :
    Tendsto
      (fun n => popSDAttr ν (gHat g θhat n))
      atTop
      (nhds (popSDAttr ν (g θ0))) := by
  have hvar :=
    popVarAttr_tendsto_of_GEstimationAssumptions
      (ν := ν) (g := g) (θ0 := θ0) (θhat := θhat) h

  have hsqrt :
      Tendsto Real.sqrt (nhds (popVarAttr ν (g θ0)))
        (nhds (Real.sqrt (popVarAttr ν (g θ0)))) :=
    (Real.continuous_sqrt.continuousAt).tendsto

  -- popSDAttr is defined as sqrt(popVarAttr)
  simpa [popSDAttr] using (hsqrt.comp hvar)

end
end ConjointSD

File:  ConjointSD/FinalCleanEstimate.lean
/-
ConjointSD/FinalCleanEstimate.lean

Clean plug-in convergence statements for population functionals under a fixed target
attribute distribution `ν`, when we replace oracle `g θ0` by the estimated `g (θhat n)`.

This file is noncomputable because it uses integrals.
-/

import Mathlib
import ConjointSD.Transport
import ConjointSD.EstimatedG

open Filter MeasureTheory
open scoped Topology

noncomputable section
namespace ConjointSD

universe u v

section

variable {Attr : Type u} [MeasurableSpace Attr]
variable (ν : Measure Attr) [IsProbabilityMeasure ν]

variable {Θ : Type v}
variable (g : Θ → Attr → ℝ)
variable (θ0 : Θ) (θhat : ℕ → Θ)

/-- Plug-in estimate of population mean under ν using θhat n. -/
def meanPlugIn (n : ℕ) : ℝ :=
  popMeanAttr ν (gHat g θhat n)

/-- Plug-in estimate of population second moment under ν using θhat n. -/
def m2PlugIn (n : ℕ) : ℝ :=
  popM2Attr ν (gHat g θhat n)

/-- Plug-in estimate of population variance under ν using θhat n. -/
def varPlugIn (n : ℕ) : ℝ :=
  popVarAttr ν (gHat g θhat n)

/-- Plug-in estimate of population SD under ν using θhat n. -/
def sdPlugIn (n : ℕ) : ℝ :=
  popSDAttr ν (gHat g θhat n)

theorem meanPlugIn_tendsto
    (h : GEstimationAssumptions (ν := ν) g θ0 θhat) :
    Tendsto
      (fun n => meanPlugIn (ν := ν) (g := g) (θhat := θhat) n)
      atTop
      (nhds (popMeanAttr ν (g θ0))) := by
  simpa [meanPlugIn] using
    (popMeanAttr_tendsto_of_GEstimationAssumptions
      (ν := ν) (g := g) (θ0 := θ0) (θhat := θhat) h)

theorem m2PlugIn_tendsto
    (h : GEstimationAssumptions (ν := ν) g θ0 θhat) :
    Tendsto
      (fun n => m2PlugIn (ν := ν) (g := g) (θhat := θhat) n)
      atTop
      (nhds (popM2Attr ν (g θ0))) := by
  simpa [m2PlugIn] using
    (popM2Attr_tendsto_of_GEstimationAssumptions
      (ν := ν) (g := g) (θ0 := θ0) (θhat := θhat) h)

theorem varPlugIn_tendsto
    (h : GEstimationAssumptions (ν := ν) g θ0 θhat) :
    Tendsto
      (fun n => varPlugIn (ν := ν) (g := g) (θhat := θhat) n)
      atTop
      (nhds (popVarAttr ν (g θ0))) := by
  simpa [varPlugIn] using
    (popVarAttr_tendsto_of_GEstimationAssumptions
      (ν := ν) (g := g) (θ0 := θ0) (θhat := θhat) h)

theorem sdPlugIn_tendsto
    (h : GEstimationAssumptions (ν := ν) g θ0 θhat) :
    Tendsto
      (fun n => sdPlugIn (ν := ν) (g := g) (θhat := θhat) n)
      atTop
      (nhds (popSDAttr ν (g θ0))) := by
  simpa [sdPlugIn] using
    (popSDAttr_tendsto_of_GEstimationAssumptions
      (ν := ν) (g := g) (θ0 := θ0) (θhat := θhat) h)

/-- Convenience corollary: the clean SD plug-in estimator is consistent (Tendsto). -/
theorem sdPlugIn_consistent
    (h : GEstimationAssumptions (ν := ν) g θ0 θhat) :
    Tendsto
      (fun n => sdPlugIn (ν := ν) (g := g) (θhat := θhat) n)
      atTop
      (nhds (popSDAttr ν (g θ0))) :=
  sdPlugIn_tendsto (ν := ν) (g := g) (θ0 := θ0) (θhat := θhat) h

end

end ConjointSD

File:  ConjointSD/FunctionalContinuityAssumptions.lean
/-
ConjointSD/FunctionalContinuityAssumptions.lean

Helper lemmas for Route 2.

Important: `FunctionalContinuityAssumptions` is already defined elsewhere
(currently in `ConjointSD.RegressionConsistencyBridge`), and its field names may
differ. So this file never refers to fields like `.mean_cont`; instead, it
extracts the needed `ContinuousAt` facts by type.
-/

import ConjointSD.RegressionConsistencyBridge
import ConjointSD.Transport

open Filter MeasureTheory
open scoped Topology

noncomputable section
namespace ConjointSD

universe u v

section

variable {Attr : Type u} [MeasurableSpace Attr]
variable {Θ : Type v} [TopologicalSpace Θ]

variable (ν : Measure Attr) [IsProbabilityMeasure ν]
variable (g : Θ → Attr → ℝ) (θ0 : Θ)

/-- Extract mean-continuity at `θ0` from `FunctionalContinuityAssumptions` (field-name free). -/
theorem meanContinuousAt_of_FunctionalContinuityAssumptions
    (hC : FunctionalContinuityAssumptions (ν := ν) (g := g) θ0) :
    ContinuousAt (fun θ => popMeanAttr ν (g θ)) θ0 := by
  rcases hC with ⟨h1, h2⟩
  first
  | simpa using h1
  | simpa using h2

/-- Extract second-moment continuity at `θ0` from `FunctionalContinuityAssumptions` (field-name free). -/
theorem m2ContinuousAt_of_FunctionalContinuityAssumptions
    (hC : FunctionalContinuityAssumptions (ν := ν) (g := g) θ0) :
    ContinuousAt (fun θ => popM2Attr ν (g θ)) θ0 := by
  rcases hC with ⟨h1, h2⟩
  first
  | simpa using h1
  | simpa using h2

/-- If `θhat → θ0`, then the population mean plug-in converges by continuity. -/
theorem popMeanAttr_tendsto_of_theta_tendsto
    {θhat : ℕ → Θ}
    (hθ : Tendsto θhat atTop (nhds θ0))
    (hC : FunctionalContinuityAssumptions (ν := ν) (g := g) θ0) :
    Tendsto
      (fun n => popMeanAttr ν (g (θhat n)))
      atTop
      (nhds (popMeanAttr ν (g θ0))) := by
  have hMeanCont :
      ContinuousAt (fun θ => popMeanAttr ν (g θ)) θ0 :=
    meanContinuousAt_of_FunctionalContinuityAssumptions (ν := ν) (g := g) (θ0 := θ0) hC
  simpa using (hMeanCont.tendsto.comp hθ)

/-- If `θhat → θ0`, then the population second-moment plug-in converges by continuity. -/
theorem popM2Attr_tendsto_of_theta_tendsto
    {θhat : ℕ → Θ}
    (hθ : Tendsto θhat atTop (nhds θ0))
    (hC : FunctionalContinuityAssumptions (ν := ν) (g := g) θ0) :
    Tendsto
      (fun n => popM2Attr ν (g (θhat n)))
      atTop
      (nhds (popM2Attr ν (g θ0))) := by
  have hM2Cont :
      ContinuousAt (fun θ => popM2Attr ν (g θ)) θ0 :=
    m2ContinuousAt_of_FunctionalContinuityAssumptions (ν := ν) (g := g) (θ0 := θ0) hC
  simpa using (hM2Cont.tendsto.comp hθ)

/-- If `θhat → θ0`, then the population variance proxy plug-in converges. -/
theorem popVarAttr_tendsto_of_theta_tendsto
    {θhat : ℕ → Θ}
    (hθ : Tendsto θhat atTop (nhds θ0))
    (hC : FunctionalContinuityAssumptions (ν := ν) (g := g) θ0) :
    Tendsto
      (fun n => popVarAttr ν (g (θhat n)))
      atTop
      (nhds (popVarAttr ν (g θ0))) := by
  have hMean :
      Tendsto
        (fun n => popMeanAttr ν (g (θhat n)))
        atTop
        (nhds (popMeanAttr ν (g θ0))) :=
    popMeanAttr_tendsto_of_theta_tendsto (ν := ν) (g := g) (θ0 := θ0) hθ hC

  have hM2 :
      Tendsto
        (fun n => popM2Attr ν (g (θhat n)))
        atTop
        (nhds (popM2Attr ν (g θ0))) :=
    popM2Attr_tendsto_of_theta_tendsto (ν := ν) (g := g) (θ0 := θ0) hθ hC

  have hMeanSq :
      Tendsto
        (fun n => (popMeanAttr ν (g (θhat n))) ^ 2)
        atTop
        (nhds ((popMeanAttr ν (g θ0)) ^ 2)) := by
    simpa [pow_two] using (hMean.mul hMean)

  have hVar :
      Tendsto
        (fun n =>
          popM2Attr ν (g (θhat n)) - (popMeanAttr ν (g (θhat n))) ^ 2)
        atTop
        (nhds (popM2Attr ν (g θ0) - (popMeanAttr ν (g θ0)) ^ 2)) :=
    hM2.sub hMeanSq

  simpa [popVarAttr] using hVar

/-- If `θhat → θ0`, then the population SD plug-in converges (sqrt ∘ var). -/
theorem popSDAttr_tendsto_of_theta_tendsto
    {θhat : ℕ → Θ}
    (hθ : Tendsto θhat atTop (nhds θ0))
    (hC : FunctionalContinuityAssumptions (ν := ν) (g := g) θ0) :
    Tendsto
      (fun n => popSDAttr ν (g (θhat n)))
      atTop
      (nhds (popSDAttr ν (g θ0))) := by
  have hVar :
      Tendsto
        (fun n => popVarAttr ν (g (θhat n)))
        atTop
        (nhds (popVarAttr ν (g θ0))) :=
    popVarAttr_tendsto_of_theta_tendsto (ν := ν) (g := g) (θ0 := θ0) hθ hC

  have hsqrt :
      Tendsto Real.sqrt (nhds (popVarAttr ν (g θ0)))
        (nhds (Real.sqrt (popVarAttr ν (g θ0)))) :=
    (Real.continuous_sqrt.continuousAt).tendsto

  simpa [popSDAttr] using (hsqrt.comp hVar)

end

end ConjointSD

File:  ConjointSD/ModelBridge.lean
import Mathlib
import ConjointSD.VarianceDecompositionFromBlocks
import ConjointSD.ConjointIdentification

open scoped BigOperators
open Filter MeasureTheory ProbabilityTheory

noncomputable section
namespace ConjointSD

/-!
# Model bridge: from linear score models to block/component scores
-/

/-- An additive linear-in-terms score function. -/
def gLin {Attr Term : Type*} [Fintype Term]
    (β : Term → ℝ) (φ : Term → Attr → ℝ) : Attr → ℝ :=
  fun a => ∑ t, β t * φ t a

/--
Block score defined by summing the terms assigned to block `b`.

We use an `if` formulation so the additivity proof is just sum-swapping + `simp`.
-/
def gBlockTerm {Attr B Term : Type*} [Fintype B] [Fintype Term] [DecidableEq B]
    (blk : Term → B) (β : Term → ℝ) (φ : Term → Attr → ℝ) : B → Attr → ℝ :=
  fun b a => ∑ t, (if blk t = b then (β t * φ t a) else 0)

/--
**Additivity bridge:** allocating each model term to exactly one block implies the total score
equals the sum of block scores.
-/
theorem gLin_eq_gTotal_blocks
    {Attr B Term : Type*}
    [Fintype B] [Fintype Term] [DecidableEq B]
    (blk : Term → B) (β : Term → ℝ) (φ : Term → Attr → ℝ) :
    gLin (β := β) (φ := φ)
      =
    gTotal (B := B) (g := gBlockTerm (blk := blk) (β := β) (φ := φ)) := by
  classical
  funext a

  -- Prove RHS = LHS pointwise, then flip.
  have h :
      gTotal (B := B) (g := gBlockTerm (blk := blk) (β := β) (φ := φ)) a
        =
      gLin (β := β) (φ := φ) a := by
    calc
      gTotal (B := B) (g := gBlockTerm (blk := blk) (β := β) (φ := φ)) a
          = (∑ b : B, ∑ t : Term, (if blk t = b then (β t * φ t a) else 0)) := by
              simp [gTotal, gBlockTerm]
      _   = (∑ t : Term, ∑ b : B, (if blk t = b then (β t * φ t a) else 0)) := by
              -- swap the two finite sums
              simpa using
                (Finset.sum_comm
                  (s := (Finset.univ : Finset B))
                  (t := (Finset.univ : Finset Term))
                  (f := fun b t => (if blk t = b then (β t * φ t a) else 0)))
      _   = (∑ t : Term, (β t * φ t a)) := by
              -- inner sum over b picks exactly b = blk t
              refine Finset.sum_congr rfl ?_
              intro t ht
              -- `simp` knows how to evaluate `∑ b, if blk t = b then r else 0`
              simp [eq_comm]
      _   = gLin (β := β) (φ := φ) a := by
              simp [gLin]

  simpa using h.symm

/-!
## Optional: connect to the conjoint causal estimand
-/

/-- Conjoint causal estimand as a function of profiles: `g⋆ x = E[Y(x)]`. -/
def gStar {Ω Attr : Type*} [MeasurableSpace Ω]
    (μ : Measure Ω) (Y : Attr → Ω → ℝ) : Attr → ℝ :=
  fun x => potMean (μ := μ) Y x

/-- Well-specification: the causal estimand lies in the linear-in-terms model class. -/
def WellSpecified
    {Ω Attr Term : Type*}
    [MeasurableSpace Ω] [Fintype Term]
    (μ : Measure Ω) (Y : Attr → Ω → ℝ)
    (β : Term → ℝ) (φ : Term → Attr → ℝ) : Prop :=
  ∀ x, gLin (β := β) (φ := φ) x = gStar (μ := μ) (Y := Y) x

/--
If the estimand is well-specified by a linear-in-terms model, then it decomposes into blocks
(using the chosen term-to-block assignment).
-/
theorem gStar_eq_sum_blocks_of_WellSpecified
    {Ω Attr B Term : Type*}
    [MeasurableSpace Ω] [Fintype B] [Fintype Term] [DecidableEq B]
    (μ : Measure Ω) (Y : Attr → Ω → ℝ)
    (blk : Term → B) (β : Term → ℝ) (φ : Term → Attr → ℝ)
    (hspec : WellSpecified (μ := μ) (Y := Y) (β := β) (φ := φ)) :
    gStar (μ := μ) (Y := Y)
      =
    gTotal (B := B) (g := gBlockTerm (blk := blk) (β := β) (φ := φ)) := by
  classical
  funext x
  have hblocks :
      gLin (β := β) (φ := φ)
        =
      gTotal (B := B) (g := gBlockTerm (blk := blk) (β := β) (φ := φ)) :=
    gLin_eq_gTotal_blocks (B := B) (Term := Term) (blk := blk) (β := β) (φ := φ)

  calc
    gStar (μ := μ) (Y := Y) x
        = gLin (β := β) (φ := φ) x := by
            simpa [WellSpecified] using (hspec x).symm
    _   = gTotal (B := B) (g := gBlockTerm (blk := blk) (β := β) (φ := φ)) x := by
            simpa using congrArg (fun f => f x) hblocks

end ConjointSD

File:  ConjointSD/OracleSDConsistency.lean
/-
ConjointSD/OracleSDConsistency.lean

Restate the existing SLLN-based SD consistency theorem so that the limit is expressed
as `popSDAttr ν g` (paper-facing object) rather than `popSDZ ...` (probability-space object).

This wires:
- SDDecompositionFromConjoint (sdHatZ → popSDZ)
to
- PopulationBridge / Transport (popSDZ = popSDAttr ν g under law(A0)=ν).
-/

import ConjointSD.SDDecompositionFromConjoint
import ConjointSD.PopulationBridge

open Filter MeasureTheory ProbabilityTheory
open scoped BigOperators

noncomputable section
namespace ConjointSD

section

variable {Ω : Type*} [MeasurableSpace Ω]
variable (μ : Measure Ω) [IsProbabilityMeasure μ]

variable {Attr : Type*} [MeasurableSpace Attr]
variable (A : ℕ → Ω → Attr)
variable (ν : Measure Attr)

/--
If `A i` are i.i.d.-type draws and `g` is fixed (oracle score),
and `A 0` has law `ν`, then the empirical SD of `g(A i)` converges a.s. to `popSDAttr ν g`.
-/
theorem sd_component_consistent_to_popSDAttr
    (g : Attr → ℝ)
    (hScore : ScoreAssumptions (μ := μ) (A := A) g)
    (hA0 : Measurable (A 0))
    (hLaw : Measure.map (A 0) μ = ν) :
    ∀ᵐ ω ∂μ,
      Tendsto
        (fun n : ℕ => sdHatZ (Z := Zcomp (A := A) (g := g)) n ω)
        atTop
        (nhds (popSDAttr ν g)) := by
  -- existing result: sdHatZ → popSDZ (on Ω)
  have hSDZ :
      ∀ᵐ ω ∂μ,
        Tendsto
          (fun n : ℕ => sdHatZ (Z := Zcomp (A := A) (g := g)) n ω)
          atTop
          (nhds (popSDZ (μ := μ) (Z := Zcomp (A := A) (g := g)))) :=
    sd_component_consistent (μ := μ) (A := A) (g := g) hScore

  -- rewrite the limit using PopulationBridge
  have hEq :
      popSDZ (μ := μ) (Z := Zcomp (A := A) (g := g)) = popSDAttr ν g :=
    popSDZ_Zcomp_eq_popSDAttr (μ := μ) (A := A) (ν := ν)
      (g := g) (hA0 := hA0) (hg := hScore.meas_g) (hLaw := hLaw)

  simpa [hEq] using hSDZ

end

end ConjointSD

File:  ConjointSD/PaperCoreEstimand.lean
/-
ConjointSD/PaperCoreEstimand.lean

Core estimand used in the paper: population SDs of block contributions (and of the total score),
expressed in terms of the “true block score” induced by the linear-in-terms model.
-/

import ConjointSD.TrueBlockEstimand
import ConjointSD.PaperWrappers

open Filter MeasureTheory ProbabilityTheory
open scoped Topology BigOperators

noncomputable section
namespace ConjointSD

/-!
## Core paper target: population SDs of true block contributions
-/

section CoreEstimand

variable {Attr : Type*} [MeasurableSpace Attr]
variable {B : Type*} [Fintype B] [DecidableEq B]
variable {Term : Type*} [Fintype Term]

variable (blk : Term → B) (β0 : Term → ℝ) (φ : Term → Attr → ℝ)

variable (ν : Measure Attr) [IsProbabilityMeasure ν]

/-- Paper’s “true block score”: the block contribution `Attr → ℝ` for block `b`. -/
def paperTrueBlockScore (blk : Term → B) (β0 : Term → ℝ) (φ : Term → Attr → ℝ) (b : B) : Attr → ℝ :=
  trueBlockScore blk β0 φ b

/-- Paper’s “true total score”: additive sum of block contributions. -/
def paperTrueTotalScore (blk : Term → B) (β0 : Term → ℝ) (φ : Term → Attr → ℝ) : Attr → ℝ := by
  classical
  exact fun a => ∑ b : B, paperTrueBlockScore (blk := blk) (β0 := β0) (φ := φ) b a

/-- Population SD of the true block score for block `b` under `ν`. -/
def paperBlockSD
    (ν : Measure Attr) [IsProbabilityMeasure ν]
    (blk : Term → B) (β0 : Term → ℝ) (φ : Term → Attr → ℝ) (b : B) : ℝ :=
  popSDAttr ν (paperTrueBlockScore blk β0 φ b)

/-- Population SD of the true total score under `ν`. -/
def paperTotalSD
    (ν : Measure Attr) [IsProbabilityMeasure ν]
    (blk : Term → B) (β0 : Term → ℝ) (φ : Term → Attr → ℝ) : ℝ :=
  popSDAttr ν (paperTrueTotalScore (blk := blk) (β0 := β0) (φ := φ))

/-- Vector of paper block-SD targets. -/
def paperBlockSDs
    (ν : Measure Attr) [IsProbabilityMeasure ν]
    (blk : Term → B) (β0 : Term → ℝ) (φ : Term → Attr → ℝ) : B → ℝ :=
  fun b => paperBlockSD (ν := ν) blk β0 φ b

theorem paperBlockSDs_apply
    (ν : Measure Attr) [IsProbabilityMeasure ν]
    (blk : Term → B) (β0 : Term → ℝ) (φ : Term → Attr → ℝ) (b : B) :
    paperBlockSDs (ν := ν) blk β0 φ b = paperBlockSD (ν := ν) blk β0 φ b := rfl

theorem paperTotalSD_def
    (ν : Measure Attr) [IsProbabilityMeasure ν]
    (blk : Term → B) (β0 : Term → ℝ) (φ : Term → Attr → ℝ) :
    paperTotalSD (ν := ν) blk β0 φ
      =
    popSDAttr ν (paperTrueTotalScore (blk := blk) (β0 := β0) (φ := φ)) := rfl

end CoreEstimand

end ConjointSD

File:  ConjointSD/PaperWrappers.lean
/-
ConjointSD/PaperWrappers.lean

A “paper-facing” wrapper layer that exposes the main checked implications in vocabulary
closest to the manuscript:

1) Conjoint identification (conditional means identify potential-outcome means; AMCE as
   difference of observed conditional means).

2) Regression / term model bridge to block decomposition (well-specification implies the
   causal estimand decomposes as a sum of block scores).

3) Route-2 sequential consistency for SDs (via θhat → θ0 + continuity at θ0):
   - per-block SDs are sequentially consistent (single M for all blocks, finite B),
   - total-score SD is sequentially consistent,
   - combined statement (blocks + total) with a single M.

4) “Convergence to the true estimand” is obtained by adding an explicit target-equality
   assumption (typically InvarianceAE / well-specification), plus AE-congruence lemmas
   showing population SDs match when score functions match ν-a.e.
-/

import Mathlib
import ConjointSD.ConjointIdentification
import ConjointSD.ModelBridge
import ConjointSD.Transport
import ConjointSD.DecompositionSequentialConsistency
import ConjointSD.TargetEquivalence
import ConjointSD.DeriveGEstimationAssumptions

open Filter MeasureTheory ProbabilityTheory
open scoped Topology BigOperators

noncomputable section
namespace ConjointSD

/-!
## 1) Conjoint identification wrappers
-/

section Identification

variable {Ω : Type*} [MeasurableSpace Ω]
variable (μ : Measure Ω) [IsProbabilityMeasure μ]
variable {Attr : Type*}
variable (X : Ω → Attr) (Y : Attr → Ω → ℝ) (Yobs : Ω → ℝ)

/-- Identification: observed conditional mean among `X = x0` equals the potential-outcome mean. -/
theorem paper_identifies_potMean_from_condMean
    (h : ConjointIdAssumptions (μ := μ) X Y Yobs)
    (x0 : Attr) :
    condMean (μ := μ) Yobs (eventX (X := X) x0) = potMean (μ := μ) Y x0 :=
  identified_potMean_from_condMean (μ := μ) (X := X) (Y := Y) (Yobs := Yobs) h x0

/-- Identification: AMCE equals a difference of observed conditional means. -/
theorem paper_identifies_amce_from_condMeans
    (h : ConjointIdAssumptions (μ := μ) X Y Yobs)
    (x x' : Attr) :
    (condMean (μ := μ) Yobs (eventX (X := X) x')
      - condMean (μ := μ) Yobs (eventX (X := X) x))
      =
    amce (μ := μ) Y x x' :=
  identified_amce_from_condMeans (μ := μ) (X := X) (Y := Y) (Yobs := Yobs) h x x'

end Identification

/-!
## 2) Regression/terms-to-block decomposition wrapper
-/

section ModelToBlocks

variable {Ω : Type*} [MeasurableSpace Ω]
variable {Attr : Type*}
variable {B : Type*} [Fintype B]
variable {Term : Type*} [Fintype Term] [DecidableEq B]

variable (μ : Measure Ω)
variable (Y : Attr → Ω → ℝ)
variable (blk : Term → B) (β : Term → ℝ) (φ : Term → Attr → ℝ)

/--
If the causal estimand is well-specified by a linear-in-terms model, it decomposes
as the sum of block scores induced by `blk`.
-/
theorem paper_gStar_eq_sum_blocks_of_WellSpecified
    (hspec : WellSpecified (μ := μ) (Y := Y) (β := β) (φ := φ)) :
    gStar (μ := μ) (Y := Y)
      =
    gTotal (B := B) (g := gBlockTerm (blk := blk) (β := β) (φ := φ)) :=
  gStar_eq_sum_blocks_of_WellSpecified
    (μ := μ) (Y := Y) (blk := blk) (β := β) (φ := φ) hspec

end ModelToBlocks

/-!
## 3) Route-2 sequential SD consistency wrappers (blocks + total)
-/

section SDSequentialConsistency

variable {Ω : Type*} [MeasurableSpace Ω]
variable {Attr : Type*} [MeasurableSpace Attr]
variable {Θ : Type*} [TopologicalSpace Θ]
variable {B : Type*} [Fintype B]

variable (μ : Measure Ω) [IsProbabilityMeasure μ]
variable (A : ℕ → Ω → Attr)

variable (ν : Measure Attr) [IsProbabilityMeasure ν]

variable (gB : B → Θ → Attr → ℝ) (θ0 : Θ) (θhat : ℕ → Θ)

/-- Paper-facing: per-block SDs are sequentially consistent (single `M` works for all blocks). -/
theorem paper_sd_blocks_sequential_consistency_ae
    (hLaw : Measure.map (A 0) μ = ν)
    (hSplit : ∀ m b,
      SplitEvalAssumptions (μ := μ) (A := A) (g := gBlock (gB := gB) b) (θhat := θhat) m)
    (hθ : Tendsto θhat atTop (nhds θ0))
    (hCont : ∀ b : B, FunctionalContinuityAssumptions (ν := ν) (g := gBlock (gB := gB) b) θ0)
    (ε : ℝ) (hε : 0 < ε) :
    ∃ M : ℕ,
      ∀ m ≥ M,
        ∀ b : B,
          (∀ᵐ ω ∂μ,
            ∀ᶠ n : ℕ in atTop,
              totalErr μ A ν (gBlock (gB := gB) b) θ0 θhat m n ω < ε) := by
  have hG :
      ∀ b : B,
        GEstimationAssumptions (ν := ν) (g := gBlock (gB := gB) b) (θ0 := θ0) (θhat := θhat) :=
    fun b =>
      derive_hG (ν := ν) (g := gBlock (gB := gB) b) (θ0 := θ0) (θhat := θhat) hθ (hCont b)
  exact
    sequential_consistency_blocks_ae
      (μ := μ) (A := A) (ν := ν) (hLaw := hLaw)
      (gB := gB) (θ0 := θ0) (θhat := θhat)
      (hSplit := hSplit) (hG := hG)
      (ε := ε) (hε := hε)

/-- Paper-facing: total-score SD is sequentially consistent. -/
theorem paper_sd_total_sequential_consistency_ae
    (hLaw : Measure.map (A 0) μ = ν)
    (hSplitTotal :
      ∀ m,
        SplitEvalAssumptions (μ := μ) (A := A) (g := gTotalΘ (gB := gB)) (θhat := θhat) m)
    (hθ : Tendsto θhat atTop (nhds θ0))
    (hContTotal :
      FunctionalContinuityAssumptions (ν := ν) (g := gTotalΘ (gB := gB)) θ0)
    (ε : ℝ) (hε : 0 < ε) :
    ∃ M : ℕ,
      ∀ m ≥ M,
        (∀ᵐ ω ∂μ,
          ∀ᶠ n : ℕ in atTop,
            totalErr μ A ν (gTotalΘ (gB := gB)) θ0 θhat m n ω < ε) := by
  have hGTotal :
      GEstimationAssumptions (ν := ν) (g := gTotalΘ (gB := gB)) (θ0 := θ0) (θhat := θhat) :=
    derive_hG (ν := ν) (g := gTotalΘ (gB := gB)) (θ0 := θ0) (θhat := θhat) hθ hContTotal
  exact
    sequential_consistency_total_ae
      (μ := μ) (A := A) (ν := ν) (hLaw := hLaw)
      (gB := gB) (θ0 := θ0) (θhat := θhat)
      (hSplitTotal := hSplitTotal) (hGTotal := hGTotal)
      (ε := ε) (hε := hε)

/--
Combined paper-facing statement: for any ε>0, a single `M` works so that for all `m ≥ M`,
(1) all block SD errors are < ε eventually in `n` (a.e. ω), and
(2) the total-score SD error is < ε eventually in `n` (a.e. ω).
-/
theorem paper_sd_blocks_and_total_sequential_consistency_ae
    (hLaw : Measure.map (A 0) μ = ν)
    (hSplit : ∀ m b,
      SplitEvalAssumptions (μ := μ) (A := A) (g := gBlock (gB := gB) b) (θhat := θhat) m)
    (hSplitTotal :
      ∀ m,
        SplitEvalAssumptions (μ := μ) (A := A) (g := gTotalΘ (gB := gB)) (θhat := θhat) m)
    (hθ : Tendsto θhat atTop (nhds θ0))
    (hCont : ∀ b : B, FunctionalContinuityAssumptions (ν := ν) (g := gBlock (gB := gB) b) θ0)
    (hContTotal :
      FunctionalContinuityAssumptions (ν := ν) (g := gTotalΘ (gB := gB)) θ0)
    (ε : ℝ) (hε : 0 < ε) :
    ∃ M : ℕ,
      ∀ m ≥ M,
        (∀ b : B,
          (∀ᵐ ω ∂μ,
            ∀ᶠ n : ℕ in atTop,
              totalErr μ A ν (gBlock (gB := gB) b) θ0 θhat m n ω < ε))
        ∧
        (∀ᵐ ω ∂μ,
          ∀ᶠ n : ℕ in atTop,
            totalErr μ A ν (gTotalΘ (gB := gB)) θ0 θhat m n ω < ε) := by
  rcases paper_sd_blocks_sequential_consistency_ae
      (μ := μ) (A := A) (ν := ν) (gB := gB) (θ0 := θ0) (θhat := θhat)
      (hLaw := hLaw) (hSplit := hSplit) (hθ := hθ) (hCont := hCont) (ε := ε) (hε := hε)
      with ⟨Mb, hMb⟩
  rcases paper_sd_total_sequential_consistency_ae
      (μ := μ) (A := A) (ν := ν) (gB := gB) (θ0 := θ0) (θhat := θhat)
      (hLaw := hLaw) (hSplitTotal := hSplitTotal) (hθ := hθ) (hContTotal := hContTotal)
      (ε := ε) (hε := hε)
      with ⟨Mt, hMt⟩
  let M : ℕ := Nat.max Mb Mt
  refine ⟨M, ?_⟩
  intro m hm
  have hmb : m ≥ Mb := le_trans (Nat.le_max_left Mb Mt) hm
  have hmt : m ≥ Mt := le_trans (Nat.le_max_right Mb Mt) hm
  refine ⟨?_, ?_⟩
  · intro b
    exact hMb m hmb b
  · exact hMt m hmt

/-!
## 4) Turn “converges to popSDAttr ν (g θ0)” into “converges to the true SD target”
by assuming ν-a.e. equality to a declared true score function and using congruence lemmas.
-/

/--
Blocks: sequential consistency + ν-a.e. target equality packages convergence to the true block SD.
-/
theorem paper_sd_blocks_sequential_consistency_to_true_target_ae
    (hLaw : Measure.map (A 0) μ = ν)
    (hSplit : ∀ m b,
      SplitEvalAssumptions (μ := μ) (A := A) (g := gBlock (gB := gB) b) (θhat := θhat) m)
    (hθ : Tendsto θhat atTop (nhds θ0))
    (hCont : ∀ b : B, FunctionalContinuityAssumptions (ν := ν) (g := gBlock (gB := gB) b) θ0)
    (gTrueB : B → Attr → ℝ)
    (hTrueB : ∀ b : B, InvarianceAE (ν := ν) (gBlock (gB := gB) b θ0) (gTrueB b))
    (ε : ℝ) (hε : 0 < ε) :
    ∃ M : ℕ,
      ∀ m ≥ M,
        ∀ b : B,
          (∀ᵐ ω ∂μ,
            ∀ᶠ n : ℕ in atTop,
              totalErr μ A ν (gBlock (gB := gB) b) θ0 θhat m n ω < ε)
          ∧
          popSDAttr ν (gBlock (gB := gB) b θ0) = popSDAttr ν (gTrueB b) := by
  rcases paper_sd_blocks_sequential_consistency_ae
      (μ := μ) (A := A) (ν := ν) (gB := gB) (θ0 := θ0) (θhat := θhat)
      (hLaw := hLaw) (hSplit := hSplit) (hθ := hθ) (hCont := hCont) (ε := ε) (hε := hε)
      with ⟨M, hM⟩
  refine ⟨M, ?_⟩
  intro m hm b
  have hCons := hM m hm b
  have hEq :
      popSDAttr ν (gBlock (gB := gB) b θ0) = popSDAttr ν (gTrueB b) :=
    popSDAttr_congr_ae (ν := ν) (s := gBlock (gB := gB) b θ0) (t := gTrueB b) (hTrueB b)
  exact ⟨hCons, hEq⟩

/--
Total-score: sequential consistency + ν-a.e. target equality packages convergence to the true SD.
-/
theorem paper_sd_total_sequential_consistency_to_true_target_ae
    (hLaw : Measure.map (A 0) μ = ν)
    (hSplitTotal :
      ∀ m,
        SplitEvalAssumptions (μ := μ) (A := A) (g := gTotalΘ (gB := gB)) (θhat := θhat) m)
    (hθ : Tendsto θhat atTop (nhds θ0))
    (hContTotal :
      FunctionalContinuityAssumptions (ν := ν) (g := gTotalΘ (gB := gB)) θ0)
    (gTrue : Attr → ℝ)
    (hTrue : InvarianceAE (ν := ν) (gTotalΘ (gB := gB) θ0) gTrue)
    (ε : ℝ) (hε : 0 < ε) :
    ∃ M : ℕ,
      ∀ m ≥ M,
        (∀ᵐ ω ∂μ,
          ∀ᶠ n : ℕ in atTop,
            totalErr μ A ν (gTotalΘ (gB := gB)) θ0 θhat m n ω < ε)
        ∧
        popSDAttr ν (gTotalΘ (gB := gB) θ0) = popSDAttr ν gTrue := by
  rcases paper_sd_total_sequential_consistency_ae
      (μ := μ) (A := A) (ν := ν) (gB := gB) (θ0 := θ0) (θhat := θhat)
      (hLaw := hLaw) (hSplitTotal := hSplitTotal) (hθ := hθ) (hContTotal := hContTotal)
      (ε := ε) (hε := hε)
      with ⟨M, hM⟩
  refine ⟨M, ?_⟩
  intro m hm
  have hCons := hM m hm
  have hEq :
      popSDAttr ν (gTotalΘ (gB := gB) θ0) = popSDAttr ν gTrue :=
    popSDAttr_congr_ae (ν := ν) (s := gTotalΘ (gB := gB) θ0) (t := gTrue) hTrue
  exact ⟨hCons, hEq⟩

end SDSequentialConsistency

end ConjointSD

File:  ConjointSD/PopulationBridge.lean
/-
ConjointSD/PopulationBridge.lean

Bridge between:
- population functionals under an attribute distribution `ν : Measure Attr`
  (popMeanAttr/popM2Attr/popVarAttr/popSDAttr), and
- functionals on the population probability space `μ : Measure Ω` for the induced
  score process `Zcomp (A := A) (g := g)` (popMeanZ/popM2Z/popVarZ/popSDZ).

Assumption: `A 0` has law `ν` under `μ`, i.e. `Measure.map (A 0) μ = ν`.

Implementation note:
In this mathlib version, `MeasureTheory.integral_map` uses the argument name `φ` for the map.
It also expects:
- `AEMeasurable φ μ`, and
- `AEStronglyMeasurable f (Measure.map φ μ)` for the integrand.

We derive the latter from `Measurable` via `.aemeasurable.aestronglyMeasurable`.
-/

import ConjointSD.Transport
import ConjointSD.SDDecompositionFromConjoint

open Filter MeasureTheory ProbabilityTheory
open scoped BigOperators

noncomputable section
namespace ConjointSD

section

variable {Ω : Type*} [MeasurableSpace Ω]
variable (μ : Measure Ω) [IsProbabilityMeasure μ]

variable {Attr : Type*} [MeasurableSpace Attr]
variable (A : ℕ → Ω → Attr)
variable (ν : Measure Attr)

/--
Bridge for means: if `A 0 ∼ ν`, then the mean of `g(A 0)` under `μ` equals the mean of `g`
under `ν`.
-/
theorem popMeanZ_Zcomp_eq_popMeanAttr
    (g : Attr → ℝ)
    (hA0 : Measurable (A 0))
    (hg : Measurable g)
    (hLaw : Measure.map (A 0) μ = ν) :
    popMeanZ (μ := μ) (Z := Zcomp (A := A) (g := g))
      =
    popMeanAttr ν g := by
  have hg_str : AEStronglyMeasurable g (Measure.map (A 0) μ) :=
    hg.aemeasurable.aestronglyMeasurable

  have hmap :
      (∫ a, g a ∂Measure.map (A 0) μ) = (∫ ω, g (A 0 ω) ∂μ) := by
    -- change-of-variables for pushforward measures
    simpa using
      (MeasureTheory.integral_map (μ := μ) (f := g) (φ := A 0)
        hA0.aemeasurable hg_str)

  calc
    popMeanZ (μ := μ) (Z := Zcomp (A := A) (g := g))
        = (∫ ω, g (A 0 ω) ∂μ) := by
            simp [popMeanZ, Zcomp]
    _   = (∫ a, g a ∂Measure.map (A 0) μ) := by
            simpa using hmap.symm
    _   = (∫ a, g a ∂ν) := by
            simpa [hLaw]
    _   = popMeanAttr ν g := by
            simp [popMeanAttr]

/--
Bridge for second moments: if `A 0 ∼ ν`, then `E[(g(A 0))^2]` under `μ` equals `E[(g)^2]`
under `ν`.
-/
theorem popM2Z_Zcomp_eq_popM2Attr
    (g : Attr → ℝ)
    (hA0 : Measurable (A 0))
    (hg : Measurable g)
    (hLaw : Measure.map (A 0) μ = ν) :
    popM2Z (μ := μ) (Z := Zcomp (A := A) (g := g))
      =
    popM2Attr ν g := by
  -- square via multiplication (avoids any separate pow measurability concerns)
  let g2 : Attr → ℝ := fun a => g a * g a
  have hg2 : Measurable g2 := by
    simpa [g2] using (hg.mul hg)

  have hg2_str : AEStronglyMeasurable g2 (Measure.map (A 0) μ) :=
    hg2.aemeasurable.aestronglyMeasurable

  have hmap :
      (∫ a, g2 a ∂Measure.map (A 0) μ) = (∫ ω, g2 (A 0 ω) ∂μ) := by
    simpa using
      (MeasureTheory.integral_map (μ := μ) (f := g2) (φ := A 0)
        hA0.aemeasurable hg2_str)

  calc
    popM2Z (μ := μ) (Z := Zcomp (A := A) (g := g))
        = (∫ ω, (g (A 0 ω)) ^ 2 ∂μ) := by
            simp [popM2Z, Zcomp]
    _   = (∫ ω, g2 (A 0 ω) ∂μ) := by
            simp [g2, pow_two]
    _   = (∫ a, g2 a ∂Measure.map (A 0) μ) := by
            simpa using hmap.symm
    _   = (∫ a, g2 a ∂ν) := by
            simpa [hLaw]
    _   = (∫ a, (g a) ^ 2 ∂ν) := by
            simp [g2, pow_two]
    _   = popM2Attr ν g := by
            simp [popM2Attr]

/-- Bridge for variances (proxy form): follows from the mean and second-moment bridges. -/
theorem popVarZ_Zcomp_eq_popVarAttr
    (g : Attr → ℝ)
    (hA0 : Measurable (A 0))
    (hg : Measurable g)
    (hLaw : Measure.map (A 0) μ = ν) :
    popVarZ (μ := μ) (Z := Zcomp (A := A) (g := g))
      =
    popVarAttr ν g := by
  have hmean :
      popMeanZ (μ := μ) (Z := Zcomp (A := A) (g := g)) = popMeanAttr ν g :=
    popMeanZ_Zcomp_eq_popMeanAttr (μ := μ) (A := A) (ν := ν) (g := g) hA0 hg hLaw
  have hm2 :
      popM2Z (μ := μ) (Z := Zcomp (A := A) (g := g)) = popM2Attr ν g :=
    popM2Z_Zcomp_eq_popM2Attr (μ := μ) (A := A) (ν := ν) (g := g) hA0 hg hLaw
  simp [popVarZ, popVarAttr, hmean, hm2]

/-- Bridge for SDs: follows from the variance bridge. -/
theorem popSDZ_Zcomp_eq_popSDAttr
    (g : Attr → ℝ)
    (hA0 : Measurable (A 0))
    (hg : Measurable g)
    (hLaw : Measure.map (A 0) μ = ν) :
    popSDZ (μ := μ) (Z := Zcomp (A := A) (g := g))
      =
    popSDAttr ν g := by
  have hvar :
      popVarZ (μ := μ) (Z := Zcomp (A := A) (g := g)) = popVarAttr ν g :=
    popVarZ_Zcomp_eq_popVarAttr (μ := μ) (A := A) (ν := ν) (g := g) hA0 hg hLaw
  simp [popSDZ, popSDAttr, hvar]

end

end ConjointSD

File:  ConjointSD/PredictedSD.lean
import Mathlib

open scoped BigOperators
open Filter MeasureTheory ProbabilityTheory

noncomputable section
namespace ConjointSD

variable {Ω : Type*} [MeasurableSpace Ω]
variable (μ : Measure Ω) [IsProbabilityMeasure μ]

/-- Empirical mean: (1/n) • ∑_{i<n} Z i ω. -/
def meanHatZ (Z : ℕ → Ω → ℝ) (n : ℕ) (ω : Ω) : ℝ :=
  ((n : ℝ)⁻¹) • (Finset.sum (Finset.range n) fun i => Z i ω)

/-- Empirical second moment: (1/n) • ∑_{i<n} (Z i ω)^2. -/
def m2HatZ (Z : ℕ → Ω → ℝ) (n : ℕ) (ω : Ω) : ℝ :=
  ((n : ℝ)⁻¹) • (Finset.sum (Finset.range n) fun i => (Z i ω) ^ 2)

/-- Plug-in empirical variance proxy: m2Hat - (meanHat)^2. -/
def varHatZ (Z : ℕ → Ω → ℝ) (n : ℕ) (ω : Ω) : ℝ :=
  m2HatZ (Z := Z) n ω - (meanHatZ (Z := Z) n ω) ^ 2

/-- Plug-in empirical SD proxy: √(varHat). -/
def sdHatZ (Z : ℕ → Ω → ℝ) (n : ℕ) (ω : Ω) : ℝ :=
  Real.sqrt (varHatZ (Z := Z) n ω)

/-- Population mean: ∫ Z 0 dμ. -/
def popMeanZ (Z : ℕ → Ω → ℝ) : ℝ :=
  ∫ ω, Z 0 ω ∂μ

/-- Population second moment: ∫ (Z 0)^2 dμ. -/
def popM2Z (Z : ℕ → Ω → ℝ) : ℝ :=
  ∫ ω, (Z 0 ω) ^ 2 ∂μ

/-- Population variance proxy: E[Z^2] - (E[Z])^2. -/
def popVarZ (Z : ℕ → Ω → ℝ) : ℝ :=
  popM2Z (μ := μ) Z - (popMeanZ (μ := μ) Z) ^ 2

/-- Population SD proxy: √(popVar). -/
def popSDZ (Z : ℕ → Ω → ℝ) : ℝ :=
  Real.sqrt (popVarZ (μ := μ) Z)

/-- IID + moment assumptions for applying the strong law to Z and Z^2. -/
structure IIDAssumptions (Z : ℕ → Ω → ℝ) : Prop where
  intZ  : Integrable (Z 0) μ
  indep : Pairwise (fun i j => IndepFun (Z i) (Z j) μ)
  ident : ∀ i, IdentDistrib (Z i) (Z 0) μ μ
  intZ2 : Integrable (fun ω => (Z 0 ω) ^ 2) μ

/-- Measurable squaring map on ℝ. -/
lemma measurable_sq : Measurable (fun x : ℝ => x ^ 2) := by
  simpa [pow_two] using (measurable_id.mul measurable_id)

/-- SLLN for the empirical mean. -/
lemma meanHatZ_tendsto_ae (Z : ℕ → Ω → ℝ) (h : IIDAssumptions (μ := μ) Z) :
    ∀ᵐ ω ∂μ,
      Tendsto (fun n : ℕ => meanHatZ (Z := Z) n ω) atTop
        (nhds (popMeanZ (μ := μ) Z)) := by
  simpa [meanHatZ, popMeanZ] using
    (ProbabilityTheory.strong_law_ae (μ := μ) (X := Z) h.intZ h.indep h.ident)

/-- SLLN for the empirical second moment. -/
lemma m2HatZ_tendsto_ae (Z : ℕ → Ω → ℝ) (h : IIDAssumptions (μ := μ) Z) :
    ∀ᵐ ω ∂μ,
      Tendsto (fun n : ℕ => m2HatZ (Z := Z) n ω) atTop
        (nhds (popM2Z (μ := μ) Z)) := by
  let Zsq : ℕ → Ω → ℝ := fun i ω => (Z i ω) ^ 2

  have hInt : Integrable (Zsq 0) μ := by
    simpa [Zsq] using h.intZ2

  have hInd : Pairwise (fun i j => IndepFun (Zsq i) (Zsq j) μ) := by
    intro i j hij
    have hij0 : IndepFun (Z i) (Z j) μ := h.indep hij
    have : IndepFun ((fun x : ℝ => x ^ 2) ∘ (Z i)) ((fun x : ℝ => x ^ 2) ∘ (Z j)) μ :=
      hij0.comp measurable_sq measurable_sq
    simpa [Zsq, Function.comp] using this

  have hId : ∀ i, IdentDistrib (Zsq i) (Zsq 0) μ μ := by
    intro i
    have hi : IdentDistrib (Z i) (Z 0) μ μ := h.ident i
    have : IdentDistrib ((fun x : ℝ => x ^ 2) ∘ (Z i)) ((fun x : ℝ => x ^ 2) ∘ (Z 0)) μ μ :=
      hi.comp measurable_sq
    simpa [Zsq, Function.comp] using this

  have hslln :
      ∀ᵐ ω ∂μ,
        Tendsto
          (fun n : ℕ =>
            ((n : ℝ)⁻¹) • (Finset.sum (Finset.range n) fun i => Zsq i ω))
          atTop
          (nhds (∫ ω, Zsq 0 ω ∂μ)) :=
    ProbabilityTheory.strong_law_ae (μ := μ) (X := Zsq) hInt hInd hId

  simpa [m2HatZ, popM2Z, Zsq] using hslln

/-- Convergence of varHat by combining mean and second-moment limits. -/
lemma varHatZ_tendsto_ae (Z : ℕ → Ω → ℝ) (h : IIDAssumptions (μ := μ) Z) :
    ∀ᵐ ω ∂μ,
      Tendsto (fun n : ℕ => varHatZ (Z := Z) n ω) atTop
        (nhds (popVarZ (μ := μ) Z)) := by
  have hmean := meanHatZ_tendsto_ae (μ := μ) (Z := Z) h
  have hm2   := m2HatZ_tendsto_ae (μ := μ) (Z := Z) h
  refine (hmean.and hm2).mono ?_
  intro ω hω
  rcases hω with ⟨hmeanω, hm2ω⟩

  have hmean2 :
      Tendsto (fun n : ℕ => (meanHatZ (Z := Z) n ω) ^ 2) atTop
        (nhds ((popMeanZ (μ := μ) Z) ^ 2)) := by
    simpa [pow_two] using (hmeanω.mul hmeanω)

  have :
      Tendsto
        (fun n : ℕ =>
          m2HatZ (Z := Z) n ω - (meanHatZ (Z := Z) n ω) ^ 2)
        atTop
        (nhds (popM2Z (μ := μ) Z - (popMeanZ (μ := μ) Z) ^ 2)) :=
    hm2ω.sub hmean2

  simpa [varHatZ, popVarZ] using this

/-- Main theorem: sdHat → popSD almost surely. -/
theorem sdHatZ_tendsto_ae (Z : ℕ → Ω → ℝ) (h : IIDAssumptions (μ := μ) Z) :
    ∀ᵐ ω ∂μ,
      Tendsto (fun n : ℕ => sdHatZ (Z := Z) n ω) atTop
        (nhds (popSDZ (μ := μ) Z)) := by
  have hvar := varHatZ_tendsto_ae (μ := μ) (Z := Z) h
  refine hvar.mono ?_
  intro ω hω
  have hsqrt :
      Tendsto Real.sqrt (nhds (popVarZ (μ := μ) Z))
        (nhds (Real.sqrt (popVarZ (μ := μ) Z))) :=
    (Real.continuous_sqrt.continuousAt).tendsto
  simpa [sdHatZ, popSDZ] using (hsqrt.comp hω)

end ConjointSD

File:  ConjointSD/RegressionConsistencyBridge.lean
/-
ConjointSD/RegressionConsistencyBridge.lean

Route 2 bridge: derive `GEstimationAssumptions` from (i) parameter convergence `θhat → θ0`
and (ii) continuity of the induced population functionals at `θ0`.

This version matches your current `GEstimationAssumptions` interface:
  fields: `mean_tendsto` and `m2_tendsto`.

We do NOT redeclare `popSDAttr_tendsto_of_GEstimationAssumptions` (it already exists in your project).
-/

import ConjointSD.EstimatedG
import Mathlib.Topology.Basic

open Filter MeasureTheory
open scoped Topology

noncomputable section
namespace ConjointSD

/-- Θ ↦ population mean induced by a parametric score `g : Θ → Attr → ℝ` under ν. -/
def popMeanΘ {Attr Θ : Type*} [MeasurableSpace Attr]
    (ν : Measure Attr) (g : Θ → Attr → ℝ) : Θ → ℝ :=
  fun θ => popMeanAttr ν (g θ)

/-- Θ ↦ population second moment induced by `g` under ν. -/
def popM2Θ {Attr Θ : Type*} [MeasurableSpace Attr]
    (ν : Measure Attr) (g : Θ → Attr → ℝ) : Θ → ℝ :=
  fun θ => popM2Attr ν (g θ)

/--
Continuity assumptions for the induced population functionals at θ0.

These are the “plug point” for regression theory: later you discharge them using
dominated convergence / continuity of link / bounded features / etc.
-/
structure FunctionalContinuityAssumptions
    {Attr Θ : Type*} [MeasurableSpace Attr] [TopologicalSpace Θ]
    (ν : Measure Attr) (g : Θ → Attr → ℝ) (θ0 : Θ) : Prop where
  cont_mean : ContinuousAt (popMeanΘ (ν := ν) g) θ0
  cont_m2   : ContinuousAt (popM2Θ   (ν := ν) g) θ0

/--
Main bridge: if θhat → θ0 and the induced mean/second-moment functionals are continuous at θ0,
then `GEstimationAssumptions` holds.
-/
theorem GEstimationAssumptions_of_theta_tendsto
    {Attr Θ : Type*} [MeasurableSpace Attr] [TopologicalSpace Θ]
    (ν : Measure Attr) [IsProbabilityMeasure ν]
    (g : Θ → Attr → ℝ) (θ0 : Θ) (θhat : ℕ → Θ)
    (hθ : Tendsto θhat atTop (nhds θ0))
    (hcont : FunctionalContinuityAssumptions (ν := ν) g θ0) :
    GEstimationAssumptions (ν := ν) g θ0 θhat := by
  refine
    { mean_tendsto := ?_
      m2_tendsto   := ?_ }
  · -- mean_tendsto
    simpa [gHat, popMeanΘ] using (hcont.cont_mean.tendsto.comp hθ)
  · -- m2_tendsto
    simpa [gHat, popM2Θ] using (hcont.cont_m2.tendsto.comp hθ)

/--
Derived variance convergence (new name to avoid collisions).

`popVarAttr ν s = popM2Attr ν s - (popMeanAttr ν s)^2`.
So if mean and second moment converge, variance converges.
-/
theorem popVarAttr_tendsto_of_GEstimationAssumptions_bridge
    {Attr Θ : Type*} [MeasurableSpace Attr] [TopologicalSpace Θ]
    (ν : Measure Attr) [IsProbabilityMeasure ν]
    (g : Θ → Attr → ℝ) (θ0 : Θ) (θhat : ℕ → Θ)
    (hG : GEstimationAssumptions (ν := ν) g θ0 θhat) :
    Tendsto
      (fun n => popVarAttr ν (gHat g θhat n))
      atTop
      (nhds (popVarAttr ν (g θ0))) := by
  have hmean :
      Tendsto
        (fun n => popMeanAttr ν (gHat g θhat n))
        atTop
        (nhds (popMeanAttr ν (g θ0))) :=
    hG.mean_tendsto

  have hm2 :
      Tendsto
        (fun n => popM2Attr ν (gHat g θhat n))
        atTop
        (nhds (popM2Attr ν (g θ0))) :=
    hG.m2_tendsto

  have hmean_sq :
      Tendsto
        (fun n => (popMeanAttr ν (gHat g θhat n)) ^ 2)
        atTop
        (nhds ((popMeanAttr ν (g θ0)) ^ 2)) := by
    -- use continuity of x ↦ x^2
    simpa [pow_two] using (hmean.mul hmean)

  have hsub :
      Tendsto
        (fun n =>
          popM2Attr ν (gHat g θhat n) - (popMeanAttr ν (gHat g θhat n)) ^ 2)
        atTop
        (nhds (popM2Attr ν (g θ0) - (popMeanAttr ν (g θ0)) ^ 2)) :=
    hm2.sub hmean_sq

  simpa [popVarAttr] using hsub

/-!
## Blocks: continuity assumptions and resulting `GEstimationAssumptions` per block
-/

def blockScoreΘ {Attr Θ B : Type*} [MeasurableSpace Attr]
    (gB : B → Θ → Attr → ℝ) (b : B) : Θ → Attr → ℝ :=
  fun θ => gB b θ

structure BlockFunctionalContinuityAssumptions
    {Attr Θ B : Type*} [MeasurableSpace Attr] [TopologicalSpace Θ]
    (ν : Measure Attr) (gB : B → Θ → Attr → ℝ) (θ0 : Θ) : Prop where
  cont : ∀ b : B,
    FunctionalContinuityAssumptions (ν := ν) (blockScoreΘ (gB := gB) b) θ0

/-- Route-2 bridge for blocks: θhat → θ0 plus continuity per block gives `GEstimationAssumptions` per block. -/
theorem block_GEstimationAssumptions_of_theta_tendsto
    {Attr Θ B : Type*} [MeasurableSpace Attr] [TopologicalSpace Θ] [Fintype B]
    (ν : Measure Attr) [IsProbabilityMeasure ν]
    (gB : B → Θ → Attr → ℝ) (θ0 : Θ) (θhat : ℕ → Θ)
    (hθ : Tendsto θhat atTop (nhds θ0))
    (hcont : BlockFunctionalContinuityAssumptions (ν := ν) gB θ0) :
    ∀ b : B, GEstimationAssumptions (ν := ν) (blockScoreΘ (gB := gB) b) θ0 θhat := by
  intro b
  exact
    GEstimationAssumptions_of_theta_tendsto
      (ν := ν)
      (g := blockScoreΘ (gB := gB) b)
      (θ0 := θ0)
      (θhat := θhat)
      hθ
      (hcont.cont b)

end ConjointSD

File:  ConjointSD/SampleSplitting.lean
/-
ConjointSD/SampleSplitting.lean

Evaluation-stage convergence for sample-splitting arguments.

For a fixed training index `m`, treat `gHat g θhat m` as a fixed (“oracle”) score
function and apply the oracle SD consistency theorem.
-/

import ConjointSD.OracleSDConsistency
import ConjointSD.EstimatedG

open Filter MeasureTheory ProbabilityTheory
open scoped BigOperators

noncomputable section
namespace ConjointSD

section

variable {Ω : Type*} [MeasurableSpace Ω]
variable {Attr : Type*} [MeasurableSpace Attr]
variable {Θ : Type*}

/--
Assumptions needed to evaluate the empirical SD of the score `gHat g θhat m`
on draws `A n` from the evaluation process.
-/
structure SplitEvalAssumptions
    (μ : Measure Ω) (A : ℕ → Ω → Attr)
    (g : Θ → Attr → ℝ) (θhat : ℕ → Θ)
    (m : ℕ) : Prop where
  hScore : ScoreAssumptions (μ := μ) (A := A) (g := gHat g θhat m)
  hA0 : Measurable (A 0)

/--
For fixed training index `m`, the empirical SD of `gHat g θhat m (A i)` converges a.s.
to the population SD under the evaluation attribute law `law(A 0)`.
-/
theorem sdHat_fixed_m_tendsto_ae_popSDAttr
    (μ : Measure Ω) [IsProbabilityMeasure μ]
    (A : ℕ → Ω → Attr)
    (g : Θ → Attr → ℝ) (θhat : ℕ → Θ)
    (m : ℕ)
    (h : SplitEvalAssumptions (μ := μ) (A := A) (g := g) (θhat := θhat) m) :
    ∀ᵐ ω ∂μ,
      Tendsto
        (fun n : ℕ =>
          sdHatZ (Z := Zcomp (A := A) (g := gHat g θhat m)) n ω)
        atTop
        (nhds (popSDAttr (Measure.map (A 0) μ) (gHat g θhat m))) := by
  simpa using
    (sd_component_consistent_to_popSDAttr
      (μ := μ) (A := A) (ν := Measure.map (A 0) μ)
      (g := gHat g θhat m)
      (hScore := h.hScore)
      (hA0 := h.hA0)
      (hLaw := rfl))

end

end ConjointSD

File:  ConjointSD/SDDecompositionFromConjoint.lean
import ConjointSD.PredictedSD

open scoped BigOperators
open Filter MeasureTheory ProbabilityTheory

noncomputable section
namespace ConjointSD

variable {Ω : Type*} [MeasurableSpace Ω]
variable (μ : Measure Ω) [IsProbabilityMeasure μ]

variable {Attr : Type*} [MeasurableSpace Attr]

/-- i.i.d.-type assumptions on the population-record process A. -/
structure PopIID (A : ℕ → Ω → Attr) : Prop where
  measA : ∀ i, Measurable (A i)
  indepA : Pairwise (fun i j => IndepFun (A i) (A j) μ)
  identA : ∀ i, IdentDistrib (A i) (A 0) μ μ

/-- Induced real-valued process from population records via a scoring function g. -/
def Zcomp (A : ℕ → Ω → Attr) (g : Attr → ℝ) : ℕ → Ω → ℝ :=
  fun i ω => g (A i ω)

/-- Sufficient conditions to use `sdHatZ_tendsto_ae` on the induced score process. -/
structure ScoreAssumptions (A : ℕ → Ω → Attr) (g : Attr → ℝ) : Prop where
  popiid : PopIID (μ := μ) A
  meas_g : Measurable g
  int_g0 : Integrable (fun ω => g (A 0 ω)) μ
  int_g0_sq : Integrable (fun ω => (g (A 0 ω)) ^ 2) μ

/-- From `ScoreAssumptions`, derive `IIDAssumptions` for Z := Zcomp A g. -/
lemma iidAssumptions_Zcomp
    (A : ℕ → Ω → Attr) (g : Attr → ℝ)
    (h : ScoreAssumptions (μ := μ) A g) :
    IIDAssumptions (μ := μ) (Zcomp (A := A) (g := g)) := by
  let Z : ℕ → Ω → ℝ := Zcomp (A := A) (g := g)
  refine ⟨?intZ, ?indepZ, ?identZ, ?intZ2⟩
  · simpa [Z, Zcomp] using h.int_g0
  · intro i j hij
    have hijA : IndepFun (A i) (A j) μ := h.popiid.indepA hij
    have : IndepFun (g ∘ (A i)) (g ∘ (A j)) μ :=
      hijA.comp h.meas_g h.meas_g
    simpa [Z, Zcomp, Function.comp] using this
  · intro i
    have hiA : IdentDistrib (A i) (A 0) μ μ := h.popiid.identA i
    have : IdentDistrib (g ∘ (A i)) (g ∘ (A 0)) μ μ :=
      hiA.comp h.meas_g
    simpa [Z, Zcomp, Function.comp] using this
  · simpa [Z, Zcomp] using h.int_g0_sq

/-- Consistency of the plug-in SD for a single component scoring rule g. -/
theorem sd_component_consistent
    (A : ℕ → Ω → Attr) (g : Attr → ℝ)
    (h : ScoreAssumptions (μ := μ) A g) :
    ∀ᵐ ω ∂μ,
      Tendsto
        (fun n : ℕ => sdHatZ (Z := Zcomp (A := A) (g := g)) n ω)
        atTop
        (nhds (popSDZ (μ := μ) (Zcomp (A := A) (g := g)))) := by
  have hIID : IIDAssumptions (μ := μ) (Zcomp (A := A) (g := g)) :=
    iidAssumptions_Zcomp (μ := μ) (A := A) (g := g) h
  simpa using (sdHatZ_tendsto_ae (μ := μ) (Z := Zcomp (A := A) (g := g)) hIID)

/-!
Finite-family “decomposition”: blocks/buckets b : B each have a scoring rule g b.
We prove consistency of the plug-in SD for each block.
-/

variable {B : Type*} [Fintype B]

/-- Bundle assumptions for all blocks at once. -/
structure DecompAssumptions (A : ℕ → Ω → Attr) (g : B → Attr → ℝ) : Prop where
  popiid : PopIID (μ := μ) A
  meas_g : ∀ b, Measurable (g b)
  int_g0 : ∀ b, Integrable (fun ω => g b (A 0 ω)) μ
  int_g0_sq : ∀ b, Integrable (fun ω => (g b (A 0 ω)) ^ 2) μ

/-- SD consistency for any chosen block b. -/
theorem sd_block_consistent
    (A : ℕ → Ω → Attr) (g : B → Attr → ℝ)
    (h : DecompAssumptions (μ := μ) (B := B) A g)
    (b : B) :
    ∀ᵐ ω ∂μ,
      Tendsto
        (fun n : ℕ => sdHatZ (Z := Zcomp (A := A) (g := g b)) n ω)
        atTop
        (nhds (popSDZ (μ := μ) (Zcomp (A := A) (g := g b)))) := by
  have hb : ScoreAssumptions (μ := μ) (A := A) (g := g b) := by
    refine ⟨?popiid, ?meas, ?int0, ?int0sq⟩
    · exact h.popiid
    · exact h.meas_g b
    · exact h.int_g0 b
    · exact h.int_g0_sq b
  exact sd_component_consistent (μ := μ) (A := A) (g := g b) hb

end ConjointSD

File:  ConjointSD/SequentialConsistency.lean
/-
ConjointSD/SequentialConsistency.lean

Sequential consistency (“m then n”) for the *total SD error*.

We prove:

(1) For any fixed training index m, as evaluation size n → ∞,
      abs ( totalErr(m,n,ω) ) → trainErr(m)     a.e. in ω

(2) As m → ∞, trainErr(m) → 0

(3) Sequential corollary (ε–M–eventually-in-n):
    For any ε>0, ∃ M, ∀ m≥M,  (∀ᵐ ω, ∀ᶠ n, totalErr(m,n,ω) < ε).

No uniformity/joint (m,n) claim.
-/

import Mathlib
import ConjointSD.SampleSplitting
import ConjointSD.EstimatedG
import ConjointSD.Transport

open Filter MeasureTheory ProbabilityTheory
open scoped Topology

noncomputable section
namespace ConjointSD

section

variable {Ω : Type*} [MeasurableSpace Ω]
variable {Attr : Type*} [MeasurableSpace Attr]
variable {Θ : Type*}

/-- Evaluation-stage SD estimator using training index `m` and evaluation size `n`. -/
def sdEst
    (μ : Measure Ω) (A : ℕ → Ω → Attr)
    (g : Θ → Attr → ℝ) (θhat : ℕ → Θ)
    (m n : ℕ) (ω : Ω) : ℝ :=
  sdHatZ (Z := Zcomp (A := A) (g := gHat g θhat m)) n ω

/-- Oracle target SD under `ν` using the oracle score `g θ0`. -/
def sdOracle
    (ν : Measure Attr) (g : Θ → Attr → ℝ) (θ0 : Θ) : ℝ :=
  popSDAttr ν (g θ0)

/-- Training error at index `m`: SD gap between `gHat m` and oracle `g θ0` under `ν`. -/
def trainErr
    (ν : Measure Attr) (g : Θ → Attr → ℝ) (θ0 : Θ) (θhat : ℕ → Θ)
    (m : ℕ) : ℝ :=
  abs (popSDAttr ν (gHat g θhat m) - sdOracle ν g θ0)

/-- Total error at `(m,n)`: empirical SD gap to oracle SD. -/
def totalErr
    (μ : Measure Ω) (A : ℕ → Ω → Attr)
    (ν : Measure Attr) (g : Θ → Attr → ℝ) (θ0 : Θ) (θhat : ℕ → Θ)
    (m n : ℕ) (ω : Ω) : ℝ :=
  abs (sdEst μ A g θhat m n ω - sdOracle ν g θ0)

/--
Step (1): for fixed `m`, as `n → ∞`, total error → training error (a.e.).

Assumes `ν` is the law of `A 0` under `μ` (so we can rewrite the population SD target).
-/
theorem totalErr_tendsto_trainErr_fixed_m
    (μ : Measure Ω) [IsProbabilityMeasure μ]
    (A : ℕ → Ω → Attr)
    (ν : Measure Attr) [IsProbabilityMeasure ν]
    (hLaw : Measure.map (A 0) μ = ν)
    (g : Θ → Attr → ℝ) (θ0 : Θ) (θhat : ℕ → Θ)
    (m : ℕ)
    (h :
      SplitEvalAssumptions (μ := μ) (A := A) (g := g) (θhat := θhat) m) :
    ∀ᵐ ω ∂μ,
      Tendsto
        (fun n : ℕ => totalErr μ A ν g θ0 θhat m n ω)
        atTop
        (nhds (trainErr ν g θ0 θhat m)) := by
  -- Base convergence from SampleSplitting:
  have hBase_map :
      ∀ᵐ ω ∂μ,
        Tendsto
          (fun n : ℕ => sdHatZ (Z := Zcomp (A := A) (g := gHat g θhat m)) n ω)
          atTop
          (nhds (popSDAttr (Measure.map (A 0) μ) (gHat g θhat m))) :=
    sdHat_fixed_m_tendsto_ae_popSDAttr (μ := μ) (A := A) (g := g) (θhat := θhat) m h

  -- Rewrite the limit using `hLaw`.
  have hBase :
      ∀ᵐ ω ∂μ,
        Tendsto
          (fun n : ℕ => sdHatZ (Z := Zcomp (A := A) (g := gHat g θhat m)) n ω)
          atTop
          (nhds (popSDAttr ν (gHat g θhat m))) := by
    simpa [hLaw] using hBase_map

  -- Continuous mapping: x ↦ abs (x - sdOracle ν g θ0)
  have hcont :
      Continuous (fun x : ℝ => abs (x - sdOracle ν g θ0)) := by
    simpa using (continuous_abs.comp (continuous_id.sub continuous_const))

  refine hBase.mono ?_
  intro ω hω

  have ht :
      Tendsto
        (fun x : ℝ => abs (x - sdOracle ν g θ0))
        (nhds (popSDAttr ν (gHat g θhat m)))
        (nhds (abs (popSDAttr ν (gHat g θhat m) - sdOracle ν g θ0))) :=
    (hcont.continuousAt.tendsto)

  simpa [totalErr, trainErr, sdOracle, sdEst] using (ht.comp hω)

/--
Step (2): training error → 0 as `m → ∞` under `GEstimationAssumptions` for `ν`.
-/
theorem trainErr_tendsto_zero
    (ν : Measure Attr) [IsProbabilityMeasure ν]
    (g : Θ → Attr → ℝ) (θ0 : Θ) (θhat : ℕ → Θ)
    (hG :
      GEstimationAssumptions (ν := ν) (g := g) (θ0 := θ0) (θhat := θhat)) :
    Tendsto
      (fun m : ℕ => trainErr ν g θ0 θhat m)
      atTop
      (nhds 0) := by
  let c : ℝ := popSDAttr ν (g θ0)

  have hBase :
      Tendsto
        (fun m : ℕ => popSDAttr ν (gHat g θhat m))
        atTop
        (nhds c) := by
    simpa [c] using
      (popSDAttr_tendsto_of_GEstimationAssumptions
        (ν := ν) (g := g) (θ0 := θ0) (θhat := θhat) hG)

  have hcont :
      Continuous (fun x : ℝ => abs (x - c)) := by
    simpa using (continuous_abs.comp (continuous_id.sub continuous_const))

  have h1 :
      Tendsto
        (fun m : ℕ => abs (popSDAttr ν (gHat g θhat m) - c))
        atTop
        (nhds (abs (c - c))) :=
    (hcont.continuousAt.tendsto).comp hBase

  -- abs (c - c) = 0
  simpa [trainErr, sdOracle, c] using (h1.trans (by simp))

/--
Step (3): sequential ε–M–eventually-in-n consistency (a.e. over ω).

Assumptions:
- `hSplit : ∀ m, SplitEvalAssumptions ... m` gives evaluation-stage conditions for each m.
- `hLaw : Measure.map (A 0) μ = ν` identifies ν with the evaluation attribute law.
- `hG` gives convergence of the population SD under ν for gHat → g θ0.

Conclusion:
For any ε>0, ∃ M, ∀ m≥M, (∀ᵐ ω, ∀ᶠ n, totalErr ... m n ω < ε).
-/
theorem sequential_consistency_ae
    (μ : Measure Ω) [IsProbabilityMeasure μ]
    (A : ℕ → Ω → Attr)
    (ν : Measure Attr) [IsProbabilityMeasure ν]
    (hLaw : Measure.map (A 0) μ = ν)
    (g : Θ → Attr → ℝ) (θ0 : Θ) (θhat : ℕ → Θ)
    (hSplit : ∀ m, SplitEvalAssumptions (μ := μ) (A := A) (g := g) (θhat := θhat) m)
    (hG : GEstimationAssumptions (ν := ν) (g := g) (θ0 := θ0) (θhat := θhat))
    (ε : ℝ) (hε : 0 < ε) :
    ∃ M : ℕ,
      ∀ m ≥ M,
        (∀ᵐ ω ∂μ, ∀ᶠ n : ℕ in atTop, totalErr μ A ν g θ0 θhat m n ω < ε) := by
  -- training-error convergence
  have hTrain : Tendsto (fun m : ℕ => trainErr ν g θ0 θhat m) atTop (nhds 0) :=
    trainErr_tendsto_zero (ν := ν) (g := g) (θ0 := θ0) (θhat := θhat) hG

  -- pick M so that for all m≥M, trainErr m < ε/2
  have hEv :
      ∀ᶠ m : ℕ in atTop, trainErr ν g θ0 θhat m < ε / 2 := by
    -- from Tendsto to 0, use the “upper” side of tendsto_order
    have : (0 : ℝ) < ε / 2 := by
      nlinarith
    exact (tendsto_order.1 hTrain).2 (ε / 2) this

  rcases (eventually_atTop.1 hEv) with ⟨M, hM⟩
  refine ⟨M, ?_⟩
  intro m hm

  have hmTrain : trainErr ν g θ0 θhat m < ε / 2 := hM m hm
  have hSum : trainErr ν g θ0 θhat m + ε / 2 < ε := by
    nlinarith

  -- Step (1) for this m: totalErr(m,n,ω) → trainErr(m) a.e.
  have hTend :
      ∀ᵐ ω ∂μ,
        Tendsto
          (fun n : ℕ => totalErr μ A ν g θ0 θhat m n ω)
          atTop
          (nhds (trainErr ν g θ0 θhat m)) :=
    totalErr_tendsto_trainErr_fixed_m
      (μ := μ) (A := A) (ν := ν) (hLaw := hLaw) (g := g) (θ0 := θ0) (θhat := θhat)
      (m := m) (h := hSplit m)

  -- Convert pointwise Tendsto into an eventually upper bound trainErr(m) + ε/2, a.e. in ω
  have hEvN :
      ∀ᵐ ω ∂μ, ∀ᶠ n : ℕ in atTop, totalErr μ A ν g θ0 θhat m n ω < trainErr ν g θ0 θhat m + ε / 2 := by
    refine hTend.mono ?_
    intro ω ht
    have hlt : trainErr ν g θ0 θhat m < trainErr ν g θ0 θhat m + ε / 2 := by
      nlinarith [hε]
    exact (tendsto_order.1 ht).2 (trainErr ν g θ0 θhat m + ε / 2) hlt

  -- Strengthen to < ε using trainErr(m) + ε/2 < ε
  refine hEvN.mono ?_
  intro ω hω
  exact hω.mono (fun n hn => lt_trans hn hSum)

end

end ConjointSD

File:  ConjointSD/TargetEquivalence.lean
/-
ConjointSD/TargetEquivalence.lean

If two score functions are equal ν-a.e., then their population mean/second-moment/variance/SD
under ν are equal. This is the basic tool to turn “consistency to g θ0” into “consistency to
the true estimand”, once you add a WellSpecified / InvarianceAE assumption.
-/

import Mathlib
import ConjointSD.Transport

open Filter MeasureTheory
open scoped Topology

noncomputable section
namespace ConjointSD

section

variable {Attr : Type*} [MeasurableSpace Attr]
variable (ν : Measure Attr) [IsProbabilityMeasure ν]
variable {s t : Attr → ℝ}

/-- If s = t ν-a.e., then their population means are equal. -/
theorem popMeanAttr_congr_ae (h : ∀ᵐ a ∂ν, s a = t a) :
    popMeanAttr ν s = popMeanAttr ν t := by
  have : (∫ a, s a ∂ν) = (∫ a, t a ∂ν) := by
    exact integral_congr_ae h
  simpa [popMeanAttr] using this

/-- If s = t ν-a.e., then their population second moments are equal. -/
theorem popM2Attr_congr_ae (h : ∀ᵐ a ∂ν, s a = t a) :
    popM2Attr ν s = popM2Attr ν t := by
  have h2 : ∀ᵐ a ∂ν, (s a) ^ 2 = (t a) ^ 2 := by
    refine h.mono ?_
    intro a ha
    simp [ha]
  have : (∫ a, (s a) ^ 2 ∂ν) = (∫ a, (t a) ^ 2 ∂ν) := by
    exact integral_congr_ae h2
  simpa [popM2Attr] using this

/-- If s = t ν-a.e., then their population variances are equal. -/
theorem popVarAttr_congr_ae (h : ∀ᵐ a ∂ν, s a = t a) :
    popVarAttr ν s = popVarAttr ν t := by
  have hm : popMeanAttr ν s = popMeanAttr ν t :=
    popMeanAttr_congr_ae (ν := ν) (s := s) (t := t) h
  have hm2 : popM2Attr ν s = popM2Attr ν t :=
    popM2Attr_congr_ae (ν := ν) (s := s) (t := t) h
  simp [popVarAttr, hm, hm2]

/-- If s = t ν-a.e., then their population SDs are equal. -/
theorem popSDAttr_congr_ae (h : ∀ᵐ a ∂ν, s a = t a) :
    popSDAttr ν s = popSDAttr ν t := by
  have hv : popVarAttr ν s = popVarAttr ν t :=
    popVarAttr_congr_ae (ν := ν) (s := s) (t := t) h
  simp [popSDAttr, hv]

end

end ConjointSD

File:  ConjointSD/TermModelBlocks.lean
/-
ConjointSD/TermModelBlocks.lean

Define a block-score model induced by a term-level linear model, and prove the
coefficient-identification specialization needed to discharge the block-specification
assumption in the paper-facing theorems.
-/

import ConjointSD.PaperWrappers

open scoped BigOperators
open Filter MeasureTheory ProbabilityTheory
open scoped Topology

noncomputable section
namespace ConjointSD

/--
Block-score model induced by a term-level coefficient map `βOf` and term features `φ`:
each block sums the terms assigned to it.
-/
def gBTerm
    {Attr B Term Θ : Type*}
    [MeasurableSpace Attr] [Fintype B] [Fintype Term] [DecidableEq B]
    (blk : Term → B) (βOf : Θ → Term → ℝ) (φ : Term → Attr → ℝ) :
    B → Θ → Attr → ℝ :=
  fun b θ a => gBlockTerm (blk := blk) (β := βOf θ) (φ := φ) b a

/--
If `βOf θ0 = β0`, then the limiting block score induced by `gBTerm` at `θ0`
equals the “true” term-induced block score using coefficients `β0`.
-/
theorem gBTerm_blockSpec
    {Attr B Term Θ : Type*}
    [MeasurableSpace Attr] [Fintype B] [Fintype Term] [DecidableEq B]
    (blk : Term → B) (φ : Term → Attr → ℝ) (βOf : Θ → Term → ℝ)
    (β0 : Term → ℝ) (θ0 : Θ)
    (hβ : βOf θ0 = β0) :
    ∀ b x,
      gBlock (gB := gBTerm (blk := blk) (βOf := βOf) (φ := φ)) b θ0 x
        =
      gBlockTerm (blk := blk) (β := β0) (φ := φ) b x := by
  intro b x
  simp [ConjointSD.gBlock, gBTerm, hβ]

end ConjointSD

File:  ConjointSD/Transport.lean
import Mathlib

open MeasureTheory ProbabilityTheory
open scoped BigOperators

noncomputable section
namespace ConjointSD

/-!
# Transport (population prediction) layer

This file introduces:

1) A *population* probability measure `ν` on the attribute space `Attr`.
2) A *design* (conjoint profile) probability measure `π` on `Attr` (optional but useful).
3) Formal “overlap / support” assumptions between `ν` and `π`.
4) Formal “invariance” (a.k.a. external validity / stability) assumptions connecting an
   experiment-identified status function to the population status function.
5) Target population mean/variance/SD estimands as integrals under `ν`.
-/

variable {Attr : Type*} [MeasurableSpace Attr]

/-- Population mean of a score function `s : Attr → ℝ` under `ν`. -/
def popMeanAttr (ν : Measure Attr) (s : Attr → ℝ) : ℝ :=
  ∫ a, s a ∂ν

/-- Population second moment of a score function `s` under `ν`. -/
def popM2Attr (ν : Measure Attr) (s : Attr → ℝ) : ℝ :=
  ∫ a, (s a) ^ 2 ∂ν

/-- Population variance via `E[s^2] - (E[s])^2` under `ν`. -/
def popVarAttr (ν : Measure Attr) (s : Attr → ℝ) : ℝ :=
  popM2Attr (ν := ν) s - (popMeanAttr (ν := ν) s) ^ 2

/-- Population SD under `ν` (square root of `popVarAttr`). -/
def popSDAttr (ν : Measure Attr) (s : Attr → ℝ) : ℝ :=
  Real.sqrt (popVarAttr (ν := ν) s)

/-- Convenient moment conditions on `s` under a population measure `ν`. -/
structure PopulationMomentAssumptions (ν : Measure Attr) (s : Attr → ℝ) : Prop where
  int1 : Integrable s ν
  int2 : Integrable (fun a => (s a) ^ 2) ν

/--
Overlap/support condition between a population distribution `ν` and a design distribution `π`.

`ν ≪ π` means: any set of attribute profiles that is impossible under the design is also
impossible in the population (support of `ν` is contained in support of `π`).
-/
structure Overlap (ν π : Measure Attr) : Prop where
  absCont : ν ≪ π

/--
Pointwise invariance: the experiment-identified score `gExp` equals the population score `gPop`
for *all* attribute profiles.
-/
def Invariance (gExp gPop : Attr → ℝ) : Prop :=
  ∀ x, gExp x = gPop x

/--
Invariance only on population support (AE under `ν`): `gExp = gPop` holds `ν`-almost everywhere.
This is often the right minimal transport condition.
-/
def InvarianceAE (ν : Measure Attr) (gExp gPop : Attr → ℝ) : Prop :=
  ∀ᵐ x ∂ν, gExp x = gPop x

/--
Transport assumptions bundling:
- population distribution `ν` (probability measure),
- design distribution `π` (probability measure),
- overlap `ν ≪ π`,
- invariance on population support.

This is stated without yet connecting `gExp` to your Step (1) identification file; that comes next.
-/
structure TransportAssumptions
    (ν π : Measure Attr)
    (gExp gPop : Attr → ℝ) : Prop where
  popProb : IsProbabilityMeasure ν
  desProb : IsProbabilityMeasure π
  overlap : Overlap ν π
  invariance : InvarianceAE (ν := ν) gExp gPop

/-!
## The target population dispersion estimand

Given a *population* distribution `ν` over attributes and a score function `s : Attr → ℝ`
(typically the status function learned/identified from the conjoint), the target estimands are:

- `popMeanAttr ν s`
- `popVarAttr  ν s`
- `popSDAttr   ν s`

All are defined as integrals w.r.t. `ν`.
-/

end ConjointSD

File:  ConjointSD/TrueBlockEstimand.lean
/-
ConjointSD/TrueBlockEstimand.lean

Instantiate the “true target” for block SDs using a linear-in-terms representation.
-/

import ConjointSD.TermModelBlocks

open Filter MeasureTheory ProbabilityTheory
open scoped Topology BigOperators

noncomputable section
namespace ConjointSD

/-!
## 1) Term-induced “true block score” and its link to the conjoint causal estimand
-/

section TrueBlockScore

variable {Attr : Type*} [MeasurableSpace Attr]
variable {B : Type*} [Fintype B]
variable {Term : Type*} [Fintype Term] [DecidableEq B]

variable (blk : Term → B) (β0 : Term → ℝ) (φ : Term → Attr → ℝ)

/-- “True” block score induced by `(blk, β0, φ)`. -/
def trueBlockScore (b : B) : Attr → ℝ :=
  gBlockTerm (blk := blk) (β := β0) (φ := φ) b

/--
If the conjoint causal estimand is well-specified by the linear-in-terms model
`(β0, φ)`, then it equals the sum of the induced true blocks.
-/
theorem gStar_eq_sum_trueBlocks_of_WellSpecified
    {Ωe : Type*} [MeasurableSpace Ωe]
    (μe : Measure Ωe) (Y : Attr → Ωe → ℝ)
    (hspec : WellSpecified (μ := μe) (Y := Y) (β := β0) (φ := φ)) :
    gStar (μ := μe) (Y := Y)
      =
    gTotal (B := B) (g := trueBlockScore (blk := blk) (β0 := β0) (φ := φ)) := by
  classical
  simpa [trueBlockScore] using
    (gStar_eq_sum_blocks_of_WellSpecified
      (μ := μe) (Y := Y) (blk := blk) (β := β0) (φ := φ) hspec)

end TrueBlockScore

/-!
## 2) Block SD sequential consistency to the instantiated term-induced target
-/

section BlockSDToTrueTarget

variable {Attr : Type*} [MeasurableSpace Attr]
variable {B : Type*} [Fintype B]

variable {Ω : Type*} [MeasurableSpace Ω]
variable (μ : Measure Ω) [IsProbabilityMeasure μ]
variable (A : ℕ → Ω → Attr)

variable (ν : Measure Attr) [IsProbabilityMeasure ν]

variable {Θ : Type*} [TopologicalSpace Θ]
variable (gB : B → Θ → Attr → ℝ) (θ0 : Θ) (θhat : ℕ → Θ)

/--
Generic block-SD sequential consistency to a supplied “true target” `trueBlockScore`,
assuming a pointwise block-specification hypothesis at `θ0`.
-/
theorem paper_blocks_converge_to_trueBlockSDs_ae
    {Term : Type*} [Fintype Term] [DecidableEq B]
    (blk : Term → B) (β0 : Term → ℝ) (φ : Term → Attr → ℝ)
    (hLaw : Measure.map (A 0) μ = ν)
    (hSplit : ∀ m b,
      SplitEvalAssumptions (μ := μ) (A := A) (g := gBlock (gB := gB) b) (θhat := θhat) m)
    (hθ : Tendsto θhat atTop (nhds θ0))
    (hCont : ∀ b : B,
      FunctionalContinuityAssumptions (ν := ν) (g := gBlock (gB := gB) b) θ0)
    (hBlockSpec :
      ∀ b x,
        gBlock (gB := gB) b θ0 x
          =
        trueBlockScore (blk := blk) (β0 := β0) (φ := φ) b x)
    (ε : ℝ) (hε : 0 < ε) :
    ∃ M : ℕ,
      ∀ m ≥ M,
        ∀ b : B,
          (∀ᵐ ω ∂μ,
            ∀ᶠ n : ℕ in atTop,
              totalErr μ A ν (gBlock (gB := gB) b) θ0 θhat m n ω < ε)
          ∧
          popSDAttr ν (gBlock (gB := gB) b θ0)
            =
          popSDAttr ν (trueBlockScore (blk := blk) (β0 := β0) (φ := φ) b) := by
  classical

  let gTrueB : B → Attr → ℝ :=
    fun b => trueBlockScore (blk := blk) (β0 := β0) (φ := φ) b

  have hTrueB : ∀ b : B, InvarianceAE (ν := ν) (gBlock (gB := gB) b θ0) (gTrueB b) := by
    intro b
    refine ae_of_all _ ?_
    intro x
    simpa [gTrueB] using hBlockSpec b x

  simpa [gTrueB] using
    (paper_sd_blocks_sequential_consistency_to_true_target_ae
      (μ := μ) (A := A) (ν := ν) (gB := gB) (θ0 := θ0) (θhat := θhat)
      (hLaw := hLaw) (hSplit := hSplit) (hθ := hθ) (hCont := hCont)
      (gTrueB := gTrueB) (hTrueB := hTrueB)
      (ε := ε) (hε := hε))

/--
Term-model specialization: the block-specification hypothesis is discharged by
coefficient identification `βOf θ0 = β0` for the induced block-score model `gBTerm`.
-/
theorem paper_blocks_converge_to_trueBlockSDs_ae_of_gBTerm
    {Term : Type*} [Fintype Term] [DecidableEq B]
    (blk : Term → B) (φ : Term → Attr → ℝ)
    (βOf : Θ → Term → ℝ) (β0 : Term → ℝ)
    (hβ : βOf θ0 = β0)
    (hLaw : Measure.map (A 0) μ = ν)
    (hSplit : ∀ m b,
      SplitEvalAssumptions
        (μ := μ) (A := A)
        (g := gBlock (gB := gBTerm (blk := blk) (βOf := βOf) (φ := φ)) b)
        (θhat := θhat) m)
    (hθ : Tendsto θhat atTop (nhds θ0))
    (hCont : ∀ b : B,
      FunctionalContinuityAssumptions
        (ν := ν)
        (g := gBlock (gB := gBTerm (blk := blk) (βOf := βOf) (φ := φ)) b)
        θ0)
    (ε : ℝ) (hε : 0 < ε) :
    ∃ M : ℕ,
      ∀ m ≥ M,
        ∀ b : B,
          (∀ᵐ ω ∂μ,
            ∀ᶠ n : ℕ in atTop,
              totalErr μ A ν
                (gBlock (gB := gBTerm (blk := blk) (βOf := βOf) (φ := φ)) b)
                θ0 θhat m n ω < ε)
          ∧
          popSDAttr ν
            (gBlock (gB := gBTerm (blk := blk) (βOf := βOf) (φ := φ)) b θ0)
            =
          popSDAttr ν
            (trueBlockScore (blk := blk) (β0 := β0) (φ := φ) b) := by
  classical

  have hBlockSpec :
      ∀ b x,
        gBlock (gB := gBTerm (blk := blk) (βOf := βOf) (φ := φ)) b θ0 x
          =
        trueBlockScore (blk := blk) (β0 := β0) (φ := φ) b x := by
    intro b x
    have h :=
      gBTerm_blockSpec
        (blk := blk) (φ := φ) (βOf := βOf) (β0 := β0) (θ0 := θ0) hβ b x
    simpa [trueBlockScore] using h

  simpa using
    (paper_blocks_converge_to_trueBlockSDs_ae
      (μ := μ) (A := A) (ν := ν) (gB := gBTerm (blk := blk) (βOf := βOf) (φ := φ))
      (θ0 := θ0) (θhat := θhat)
      (blk := blk) (β0 := β0) (φ := φ)
      (hLaw := hLaw) (hSplit := hSplit) (hθ := hθ) (hCont := hCont)
      (hBlockSpec := hBlockSpec) (ε := ε) (hε := hε))

end BlockSDToTrueTarget

end ConjointSD

File:  ConjointSD/VarianceDecompositionFromBlocks.lean
import ConjointSD.SDDecompositionFromConjoint

open scoped BigOperators
open Filter MeasureTheory ProbabilityTheory

noncomputable section
namespace ConjointSD

variable {Ω : Type*} [MeasurableSpace Ω]
variable (μ : Measure Ω) [IsProbabilityMeasure μ]

variable {Attr : Type*} [MeasurableSpace Attr]
variable {B : Type*} [Fintype B]

/-- Total additive score. -/
def gTotal (g : B → Attr → ℝ) : Attr → ℝ :=
  fun a => Finset.sum Finset.univ (fun b => g b a)

/-- Raw covariance: E[XY] - E[X]E[Y]. -/
def covRaw (X Y : Ω → ℝ) : ℝ :=
  (∫ ω, X ω * Y ω ∂μ) - (∫ ω, X ω ∂μ) * (∫ ω, Y ω ∂μ)

/-- Variance proxy: E[X^2] - (E[X])^2. -/
def varProxy (X : Ω → ℝ) : ℝ :=
  (∫ ω, (X ω) ^ 2 ∂μ) - (∫ ω, X ω ∂μ) ^ 2

/-- Integrability assumptions for block functions and their products. -/
structure BlockIntegrable (A : ℕ → Ω → Attr) (g : B → Attr → ℝ) : Prop where
  intX : ∀ b, Integrable (fun ω => g b (A 0 ω)) μ
  intMul : ∀ b c, Integrable (fun ω => g b (A 0 ω) * g c (A 0 ω)) μ

theorem varProxy_sum_eq_sum_covRaw
    (A : ℕ → Ω → Attr) (g : B → Attr → ℝ)
    (h : BlockIntegrable (μ := μ) (A := A) (g := g)) :
    varProxy (μ := μ) (fun ω => gTotal (B := B) g (A 0 ω))
      =
    Finset.sum Finset.univ (fun b =>
      Finset.sum Finset.univ (fun c =>
        covRaw (μ := μ)
          (fun ω => g b (A 0 ω))
          (fun ω => g c (A 0 ω)))) := by
  classical

  -- X b ω = block score, S ω = total score
  let X : B → Ω → ℝ := fun b ω => g b (A 0 ω)
  let S : Ω → ℝ := fun ω => Finset.sum Finset.univ (fun b => X b ω)

  -- pair index finset
  let pairs : Finset (B × B) :=
    (Finset.univ : Finset B).product (Finset.univ : Finset B)

  -- integrability facts
  have hintX : ∀ b, Integrable (X b) μ := by
    intro b
    simpa [X] using h.intX b

  have hintMul : ∀ b c, Integrable (fun ω => X b ω * X c ω) μ := by
    intro b c
    simpa [X] using h.intMul b c

  have hintF : ∀ p : B × B, Integrable (fun ω => X p.1 ω * X p.2 ω) μ := by
    intro p
    simpa using hintMul p.1 p.2

  -- E[S] = ∑_b E[X b]
  have hmean :
      (∫ ω, S ω ∂μ) = Finset.sum Finset.univ (fun b => ∫ ω, X b ω ∂μ) := by
    simpa [S] using
      (integral_finset_sum (μ := μ) (s := (Finset.univ : Finset B))
        (f := fun b ω => X b ω)
        (fun b hb => hintX b))

  /- Helper: double-sum = product-sum pointwise (use pair-function form of `sum_product`). -/
  have hprod (ω : Ω) :
      (Finset.sum Finset.univ (fun i =>
          Finset.sum Finset.univ (fun j => X i ω * X j ω)))
        =
      (Finset.sum pairs (fun p => X p.1 ω * X p.2 ω)) := by
    -- `sum_product` gives: sum over product = double sum, so take `.symm`.
    simpa [pairs] using
      (Finset.sum_product
        (s := (Finset.univ : Finset B))
        (t := (Finset.univ : Finset B))
        (f := fun p : B × B => X p.1 ω * X p.2 ω)).symm

  -- Pointwise: S(ω)^2 = ∑_{p∈pairs} X(p.1,ω)X(p.2,ω)
  have hsq_fun :
      (fun ω => (S ω) ^ 2) = (fun ω => Finset.sum pairs (fun p => X p.1 ω * X p.2 ω)) := by
    funext ω
    calc
      (S ω) ^ 2
          = (Finset.sum Finset.univ (fun b => X b ω))
              * (Finset.sum Finset.univ (fun b => X b ω)) := by
                simp [S, pow_two]
      _ = Finset.sum Finset.univ (fun i =>
            Finset.sum Finset.univ (fun j => X i ω * X j ω)) := by
                simp [Finset.sum_mul_sum]
      _ = Finset.sum pairs (fun p => X p.1 ω * X p.2 ω) := by
                simpa using hprod (ω := ω)

  -- E[S^2] = ∑_{p∈pairs} E[X p.1 * X p.2]
  have hm2 :
      (∫ ω, (S ω) ^ 2 ∂μ)
        =
      Finset.sum pairs (fun p => ∫ ω, (X p.1 ω * X p.2 ω) ∂μ) := by
    calc
      (∫ ω, (S ω) ^ 2 ∂μ)
          = (∫ ω, Finset.sum pairs (fun p => X p.1 ω * X p.2 ω) ∂μ) := by
              simp [hsq_fun]
      _ = Finset.sum pairs (fun p => ∫ ω, (X p.1 ω * X p.2 ω) ∂μ) := by
            simpa using
              (integral_finset_sum (μ := μ) (s := pairs)
                (f := fun p ω => X p.1 ω * X p.2 ω)
                (fun p hp => hintF p))

  -- (∑_b E[X b])^2 = ∑_{pairs} E[X p.1]E[X p.2]  (pair-function form of `sum_product`)
  have hmean_sq :
      (Finset.sum Finset.univ (fun b => ∫ ω, X b ω ∂μ)) ^ 2
        =
      Finset.sum pairs (fun p =>
        (∫ ω, X p.1 ω ∂μ) * (∫ ω, X p.2 ω ∂μ)) := by
    calc
      (Finset.sum Finset.univ (fun b => ∫ ω, X b ω ∂μ)) ^ 2
          =
        (Finset.sum Finset.univ (fun b => ∫ ω, X b ω ∂μ))
          * (Finset.sum Finset.univ (fun b => ∫ ω, X b ω ∂μ)) := by
            simp [pow_two]
      _ =
        Finset.sum Finset.univ (fun i =>
          Finset.sum Finset.univ (fun j =>
            (∫ ω, X i ω ∂μ) * (∫ ω, X j ω ∂μ))) := by
            simp [Finset.sum_mul_sum]
      _ =
        Finset.sum pairs (fun p =>
          (∫ ω, X p.1 ω ∂μ) * (∫ ω, X p.2 ω ∂μ)) := by
          simpa [pairs] using
            (Finset.sum_product
              (s := (Finset.univ : Finset B))
              (t := (Finset.univ : Finset B))
              (f := fun p : B × B =>
                (∫ ω, X p.1 ω ∂μ) * (∫ ω, X p.2 ω ∂μ))).symm

  -- varProxy(S) as a pairs-sum of covRaw
  have var_as_pairs :
      varProxy (μ := μ) S =
        Finset.sum pairs (fun p => covRaw (μ := μ) (X p.1) (X p.2)) := by
    calc
      varProxy (μ := μ) S
          = (∫ ω, (S ω) ^ 2 ∂μ) - (∫ ω, S ω ∂μ) ^ 2 := by
              simp [varProxy]
      _ = (Finset.sum pairs (fun p => ∫ ω, (X p.1 ω * X p.2 ω) ∂μ))
            - (Finset.sum Finset.univ (fun b => ∫ ω, X b ω ∂μ)) ^ 2 := by
              simp [hm2, hmean]
      _ = (Finset.sum pairs (fun p => ∫ ω, (X p.1 ω * X p.2 ω) ∂μ))
            - (Finset.sum pairs (fun p =>
                (∫ ω, X p.1 ω ∂μ) * (∫ ω, X p.2 ω ∂μ))) := by
              simp [hmean_sq]
      _ = Finset.sum pairs (fun p =>
            (∫ ω, (X p.1 ω * X p.2 ω) ∂μ)
              - (∫ ω, X p.1 ω ∂μ) * (∫ ω, X p.2 ω ∂μ)) := by
              simp [Finset.sum_sub_distrib]
      _ = Finset.sum pairs (fun p => covRaw (μ := μ) (X p.1) (X p.2)) := by
            refine Finset.sum_congr rfl ?_
            intro p hp
            simp [covRaw]

  -- pairs covariance sum = nested covariance sum (pair-function form of `sum_product`)
  have hprodCov :
      (Finset.sum pairs (fun p => covRaw (μ := μ) (X p.1) (X p.2)))
        =
      (Finset.sum Finset.univ (fun b =>
        Finset.sum Finset.univ (fun c => covRaw (μ := μ) (X b) (X c)))) := by
    simpa [pairs] using
      (Finset.sum_product
        (s := (Finset.univ : Finset B))
        (t := (Finset.univ : Finset B))
        (f := fun p : B × B => covRaw (μ := μ) (X p.1) (X p.2)))

  -- gTotal relation: gTotal g (A0 ω) = S ω
  have hS : (fun ω => gTotal (B := B) g (A 0 ω)) = S := by
    funext ω
    simp [gTotal, S, X]

  calc
    varProxy (μ := μ) (fun ω => gTotal (B := B) g (A 0 ω))
        = varProxy (μ := μ) S := by simpa [hS]
    _ = Finset.sum pairs (fun p => covRaw (μ := μ) (X p.1) (X p.2)) := var_as_pairs
    _ = Finset.sum Finset.univ (fun b =>
          Finset.sum Finset.univ (fun c =>
            covRaw (μ := μ)
              (fun ω => g b (A 0 ω))
              (fun ω => g c (A 0 ω)))) := by
          simpa [X] using hprodCov

end ConjointSD

File:  ConjointSD/WellSpecifiedFromNoInteractions.lean
/-
ConjointSD/WellSpecifiedFromNoInteractions.lean

Bridge from “no interactions” (exact additivity) to `ModelBridge.WellSpecified`.

This file is self-contained except for the existing definitions of
`gLin`, `gStar`, and `WellSpecified` in `ConjointSD.ModelBridge`.
-/

import Mathlib
import ConjointSD.ModelBridge

open Filter MeasureTheory ProbabilityTheory
open scoped BigOperators

noncomputable section
namespace ConjointSD

universe u v

/-- Dependent-product profile type (all relevant variables). -/
abbrev Profile (K : Type u) (V : K → Type v) : Type (max u v) :=
  ∀ k : K, V k

section ProductProfiles

variable {K : Type u} [Fintype K]
variable {V : K → Type v}

/-- “Interaction” defined as deviation from an additive (grand-mean + main effects) form. -/
def interactionDev
    (g : Profile K V → ℝ)
    (μ0 : ℝ)
    (main : ∀ k : K, V k → ℝ)
    (a : Profile K V) : ℝ :=
  g a - (μ0 + ∑ k : K, main k (a k))

/--
Assumptions: the score function admits a grand mean + main effects representation,
and the “interaction deviation” is identically zero (so the representation is exact).
-/
structure NoInteractionsAssumptions
    (g : Profile K V → ℝ) where
  μ0   : ℝ
  main : ∀ k : K, V k → ℝ
  interaction_zero : ∀ a, interactionDev (K := K) (V := V) (g := g) μ0 main a = 0

/-- Term set for an additive model: intercept + one main-effect term per variable. -/
abbrev MainEffectTerm (K : Type*) := Option K

/-- Feature map for the additive model (intercept + main effects). -/
def φMain
    (main : ∀ k : K, V k → ℝ) :
    MainEffectTerm K → Profile K V → ℝ
  | none,   _ => 1
  | some k, a => main k (a k)

/-- Coefficients for the additive model (μ0 on intercept, 1 on each main-effect term). -/
def βMain (μ0 : ℝ) : MainEffectTerm K → ℝ
  | none   => μ0
  | some _ => 1

/--
Key algebraic lemma: the constructed linear model equals μ0 + Σ_k main k (a k).
-/
theorem gLin_eq_additive_form
    (μ0 : ℝ) (main : ∀ k : K, V k → ℝ) (a : Profile K V) :
    gLin (β := βMain (K := K) μ0) (φ := φMain (K := K) (V := V) main) a
      =
    μ0 + ∑ k : K, main k (a k) := by
  classical
  -- Split the `Option K` sum into the intercept plus the `some k` terms.
  simp [gLin, βMain, φMain, Fintype.sum_option, add_assoc, add_comm, add_left_comm, mul_assoc]

/--
Main bridge: “no interactions” (as deviation from additivity) implies `WellSpecified`
for the explicit additive term model.
-/
theorem wellSpecified_of_noInteractions
    {Ω : Type*} [MeasurableSpace Ω]
    (μe : Measure Ω)
    (Y  : Profile K V → Ω → ℝ)
    (h : NoInteractionsAssumptions (K := K) (V := V) (gStar (μ := μe) (Y := Y))) :
    WellSpecified
      (μ := μe) (Y := Y)
      (β := βMain (K := K) h.μ0)
      (φ := φMain (K := K) (V := V) h.main) := by
  intro a
  have hadd :
      gStar (μ := μe) (Y := Y) a = h.μ0 + ∑ k : K, h.main k (a k) := by
    have hz := h.interaction_zero a
    have hz' :
        gStar (μ := μe) (Y := Y) a - (h.μ0 + ∑ k : K, h.main k (a k)) = 0 := by
      simpa [interactionDev] using hz
    linarith
  calc
    gLin (β := βMain (K := K) h.μ0) (φ := φMain (K := K) (V := V) h.main) a
        =
      h.μ0 + ∑ k : K, h.main k (a k) := by
      simpa using gLin_eq_additive_form (K := K) (V := V) h.μ0 h.main a
    _ =
      gStar (μ := μe) (Y := Y) a := by
      simpa using hadd.symm

end ProductProfiles

end ConjointSD
