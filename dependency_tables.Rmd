---
title: "Dependency Tables"
output: md_document
---

This document auto-generates theorem dependency tables by parsing the output of
`Scratch.lean`.

```{r setup, echo=FALSE}
options(width = 120)
```

```{r collect, echo=FALSE}
cmd <- "lake env lean Scratch.lean"
lines <- system(cmd, intern = TRUE)

# Theorems printed from Scratch.lean.
theorem_lines <- lines[grepl("^theorem ConjointSD\\.", lines)]
theorems <- unique(sub("^theorem ConjointSD\\.([^.{ ]+).*$", "\\1", theorem_lines))
theorems <- theorems[theorems != ""]

# Expand by printing every ConjointSD reference seen in Scratch output.
refs <- unique(unlist(regmatches(lines, gregexpr("ConjointSD\\.[A-Za-z0-9_]+", lines))))
refs <- unique(sub("^ConjointSD\\.", "", refs))

run_prints <- function(names) {
  tmp_lean <- tempfile(fileext = ".lean")
  writeLines(c("import ConjointSD", paste0("#print ConjointSD.", sort(names))), tmp_lean)
  output <- suppressWarnings(
    system2("lake", c("env", "lean", tmp_lean), stdout = TRUE, stderr = TRUE)
  )
  unknown <- unique(c(
    unlist(regmatches(output, gregexpr("unknown constant 'ConjointSD\\.[A-Za-z0-9_]+'", output))),
    unlist(regmatches(output, gregexpr("Unknown constant `ConjointSD\\.[A-Za-z0-9_]+`", output)))
  ))
  unknown <- gsub("unknown constant 'ConjointSD\\.", "", unknown, ignore.case = TRUE)
  unknown <- gsub("Unknown constant `ConjointSD\\.", "", unknown, ignore.case = TRUE)
  unknown <- gsub("[`']$", "", unknown)
  list(output = output, unknown = unknown)
}

refs_known <- refs
lines_all <- character(0)
repeat {
  res <- run_prints(refs_known)
  if (length(res$unknown) == 0) {
    lines_all <- res$output
    break
  }
  next_refs <- setdiff(refs_known, res$unknown)
  if (length(next_refs) == length(refs_known)) {
    lines_all <- res$output
    break
  }
  refs_known <- next_refs
}

if (length(lines_all) == 0) {
  lines_all <- lines
}

# Structures printed from Scratch.lean (for assumption field names).
structure_lines <- lines_all[grepl("^structure ConjointSD\\.", lines_all)]
structures <- unique(sub("^structure ConjointSD\\.([^.{ ]+).*$", "\\1", structure_lines))
structures <- structures[structures != ""]

# Definitions printed from Scratch.lean (for non-structure assumptions).
def_lines <- lines_all[grepl("^def ConjointSD\\.", lines_all)]
defs <- unique(sub("^def ConjointSD\\.([^.{ ]+).*$", "\\1", def_lines))
defs <- defs[defs != ""]

# Extract #print blocks for each theorem.
block_for <- function(name, lines) {
  start_pat <- paste0("^theorem ConjointSD\\.", name, "\\.")
  idx <- grep(start_pat, lines)
  if (length(idx) == 0) return(character(0))
  start <- idx[1]
  # End at next theorem/structure print or end of file.
  next_idx <- grep("^(theorem|structure) ConjointSD\\.", lines[(start + 1):length(lines)])
  end <- if (length(next_idx) == 0) length(lines) else start + next_idx[1] - 1
  lines[start:end]
}

all_names <- unique(c(theorems, refs))
blocks <- setNames(lapply(all_names, block_for, lines = lines_all), all_names)

# Dependency graph: if a block references another theorem name, count it as a dependency.
find_deps <- function(name, block, all_names) {
  if (length(block) == 0) return(character(0))
  text <- paste(block, collapse = "\n")
  hits <- vapply(
    all_names,
    function(nm) grepl(paste0("ConjointSD.", nm), text, fixed = TRUE),
    logical(1)
  )
  all_names[all_names != name & hits]
}

raw_deps <- setNames(lapply(all_names, function(nm) find_deps(nm, blocks[[nm]], all_names)), all_names)

# Transitive closure.
all_deps <- raw_deps
changed <- TRUE
while (changed) {
  changed <- FALSE
  for (nm in theorems) {
    deps <- unique(unlist(all_deps[nm]))
    expanded <- unique(c(deps, unlist(all_deps[deps])))
    if (!setequal(deps, expanded)) {
      all_deps[[nm]] <- expanded
      changed <- TRUE
    }
  }
}

# Structure block extraction.
structure_block_for <- function(name, lines) {
  start_pat <- paste0("^structure ConjointSD\\.", name, "\\.")
  idx <- grep(start_pat, lines)
  if (length(idx) == 0) return(character(0))
  start <- idx[1]
  next_idx <- grep("^(theorem|structure) ConjointSD\\.", lines[(start + 1):length(lines)])
  end <- if (length(next_idx) == 0) length(lines) else start + next_idx[1] - 1
  lines[start:end]
}

structure_blocks <- setNames(lapply(structures, structure_block_for, lines = lines_all), structures)

parse_structure <- function(struct_name, block) {
  field_lines <- block[grepl("^  ConjointSD\\.", block)]
  if (length(field_lines) == 0) {
    return(list(fields = character(0), nested = character(0)))
  }
  field_name <- sub("^  ConjointSD\\.[^.]+\\.([^ ]+) :.*$", "\\1", field_lines)
  field_type <- sub("^  ConjointSD\\.[^.]+\\.[^ ]+ : (.*)$", "\\1", field_lines)
  nested <- unique(unlist(regmatches(field_type, gregexpr("ConjointSD\\.[A-Za-z0-9_]+", field_type))))
  nested <- sub("^ConjointSD\\.", "", nested)
  primitive <- !grepl("ConjointSD\\.", field_type)
  list(fields = field_name[primitive], nested = nested)
}

structure_info <- setNames(lapply(structures, function(s) parse_structure(s, structure_blocks[[s]])), structures)

def_block_for <- function(name, lines) {
  start_pat <- paste0("^def ConjointSD\\.", name, "([ .])")
  idx <- grep(start_pat, lines)
  if (length(idx) == 0) return(character(0))
  start <- idx[1]
  next_idx <- grep("^(theorem|structure|def) ConjointSD\\.", lines[(start + 1):length(lines)])
  end <- if (length(next_idx) == 0) length(lines) else start + next_idx[1] - 1
  lines[start:end]
}

def_blocks <- setNames(lapply(defs, def_block_for, lines = lines_all), defs)
def_is_prop <- vapply(defs, function(nm) {
  blk <- def_blocks[[nm]]
  if (length(blk) == 0) return(FALSE)
  header <- paste(blk[1:min(2, length(blk))], collapse = " ")
  grepl(": Prop", header, fixed = TRUE)
}, logical(1))
assumption_defs <- defs[def_is_prop]

structure_field_assumptions <- unique(unlist(lapply(names(structure_info), function(s) {
  fields <- structure_info[[s]]$fields
  if (length(fields) == 0) return(character(0))
  paste(s, fields)
})))

structure_nested <- lapply(structure_info, function(info) info$nested)

structure_closure <- function(struct_name, nested_map) {
  seen <- character(0)
  stack <- struct_name
  while (length(stack) > 0) {
    current <- stack[[1]]
    stack <- stack[-1]
    if (current %in% seen) next
    seen <- c(seen, current)
    if (!is.null(nested_map[[current]])) {
      stack <- c(stack, nested_map[[current]])
    }
  }
  seen
}

extract_atomic_assumptions <- function(text) {
  labels <- character(0)
  text_flat <- gsub("\n", " ", text)

  ip <- unlist(regmatches(text_flat, gregexpr("MeasureTheory.IsProbabilityMeasure [A-Za-z0-9_]+", text_flat)))
  if (length(ip) > 0) {
    labels <- c(labels, gsub("MeasureTheory.IsProbabilityMeasure ", "IsProbabilityMeasure ", ip))
  }

  meas <- unlist(regmatches(text_flat, gregexpr("Measurable \\(A 0\\)", text_flat)))
  if (length(meas) > 0) labels <- c(labels, meas)

  maps <- unlist(regmatches(text_flat, gregexpr("MeasureTheory.Measure.map \\(A 0\\) [A-Za-z0-9_]+ = [A-Za-z0-9_]+", text_flat)))
  if (length(maps) > 0) {
    labels <- c(labels, gsub("MeasureTheory.Measure.map ", "Measure map ", maps))
  }

  tendsto <- unlist(regmatches(text_flat, gregexpr("Filter.Tendsto θhat[^,)]*\\(nhds [A-Za-z0-9_]+\\)", text_flat)))
  if (length(tendsto) > 0) labels <- c(labels, tendsto)

  beta_eq <- unlist(regmatches(text_flat, gregexpr("βOf θ0 = [A-Za-z0-9_]+", text_flat)))
  if (length(beta_eq) > 0) labels <- c(labels, beta_eq)

  eps <- unlist(regmatches(text_flat, gregexpr("0 < [A-Za-z0-9_]+", text_flat)))
  if (length(eps) > 0) labels <- c(labels, eps)

  ae_eq <- unlist(regmatches(text_flat, gregexpr("∀ᵐ \\(a : Attr\\) ∂ν, s a = t a", text_flat)))
  if (length(ae_eq) > 0) labels <- c(labels, ae_eq)

  labels
}

assumption_defs_in_block <- function(text) {
  hits <- character(0)
  for (nm in assumption_defs) {
    if (grepl(paste0("ConjointSD.", nm), text, fixed = TRUE)) hits <- c(hits, nm)
  }
  hits
}

assumptions_in_block <- function(block) {
  text <- paste(block, collapse = "\n")
  hit <- character(0)

  for (s in structures) {
    if (grepl(paste0("ConjointSD.", s), text, fixed = TRUE)) {
      for (s_hit in structure_closure(s, structure_nested)) {
        fields <- structure_info[[s_hit]]$fields
        if (length(fields) > 0) {
          hit <- c(hit, paste(s_hit, fields))
        }
      }
    }
  }

  hit <- c(hit, extract_atomic_assumptions(text))
  hit <- c(hit, assumption_defs_in_block(text))
  unique(hit)
}

assumption_direct <- setNames(lapply(all_names, function(nm) assumptions_in_block(blocks[[nm]])), all_names)

assumptions <- sort(unique(c(structure_field_assumptions, unlist(assumption_direct))))

# Make assumptions transitive along theorem dependencies.
assumption_all <- lapply(assumption_direct, function(x) {
  setNames(assumptions %in% x, assumptions)
})
for (nm in all_names) {
  deps <- all_deps[[nm]]
  if (length(deps) > 0) {
    trans <- Reduce(`|`, lapply(deps, function(d) assumption_all[[d]]), init = assumption_all[[nm]])
    assumption_all[[nm]] <- trans
  }
}

sym_yes <- "✅"
sym_no <- "❌"

pretty_name <- function(x) gsub("_", " ", x, fixed = TRUE)

fmt_matrix <- function(mat, diag_omit = FALSE) {
  out <- mat
  for (i in seq_len(nrow(out))) {
    for (j in seq_len(ncol(out))) {
      if (diag_omit && i == j) {
        out[i, j] <- "Ø"
      } else {
        out[i, j] <- if (out[i, j]) sym_yes else sym_no
      }
    }
  }
  out
}

# Assumption matrix (rows = assumptions, cols = theorems).
assump_mat <- matrix(FALSE, nrow = length(assumptions), ncol = length(theorems),
                     dimnames = list(assumptions, theorems))
for (j in seq_along(theorems)) {
  assump_mat[, j] <- as.logical(assumption_all[[theorems[j]]])
}

dimnames(assump_mat) <- list(pretty_name(rownames(assump_mat)), pretty_name(colnames(assump_mat)))
assump_fmt <- fmt_matrix(assump_mat)
assump_count <- rowSums(assump_mat)

# Theorem dependency matrix (rows = theorems, cols = theorems).

dep_mat <- matrix(FALSE, nrow = length(theorems), ncol = length(theorems),
                  dimnames = list(theorems, theorems))
for (j in seq_along(theorems)) {
  col_name <- theorems[j]
  dep_mat[, j] <- theorems %in% all_deps[[col_name]]
}

dimnames(dep_mat) <- list(pretty_name(rownames(dep_mat)), pretty_name(colnames(dep_mat)))
dep_fmt <- fmt_matrix(dep_mat, diag_omit = TRUE)
```

## Auto-generated assumption matrix

```{r assumption-table, echo=FALSE}
knitr::kable(cbind(Count = assump_count, assump_fmt), align = "l")
```

## Auto-generated theorem dependency matrix

```{r dependency-table, echo=FALSE}
knitr::kable(dep_fmt, align = "l")
```
