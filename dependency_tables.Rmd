---
title: "Dependency Tables"
output: md_document
---

This document auto-generates theorem dependency tables by parsing the output of
`Scratch.lean`.

```{r setup, echo=FALSE}
options(width = 120)
```

```{r collect, echo=FALSE}
cmd <- "lake env lean Scratch.lean"
lines <- system(cmd, intern = TRUE)

# Theorems printed from Scratch.lean.
theorem_lines <- lines[grepl("^theorem ConjointSD\\.", lines)]
theorems <- unique(sub("^theorem ConjointSD\\.([^.{ ]+).*$", "\\1", theorem_lines))
theorems <- theorems[theorems != ""]

# Structures printed from Scratch.lean (for assumption field names).
structure_lines <- lines[grepl("^structure ConjointSD\\.", lines)]
structures <- unique(sub("^structure ConjointSD\\.([^.{ ]+).*$", "\\1", structure_lines))
structures <- structures[structures != ""]

# Extract #print blocks for each theorem.
block_for <- function(name, lines) {
  start_pat <- paste0("^theorem ConjointSD\\.", name, "\\.")
  idx <- grep(start_pat, lines)
  if (length(idx) == 0) return(character(0))
  start <- idx[1]
  # End at next theorem/structure print or end of file.
  next_idx <- grep("^(theorem|structure) ConjointSD\\.", lines[(start + 1):length(lines)])
  end <- if (length(next_idx) == 0) length(lines) else start + next_idx[1] - 1
  lines[start:end]
}

blocks <- setNames(lapply(theorems, block_for, lines = lines), theorems)

# Dependency graph: if a block references another theorem name, count it as a dependency.
find_deps <- function(name, block, all_names) {
  if (length(block) == 0) return(character(0))
  text <- paste(block, collapse = "\n")
  hits <- vapply(
    all_names,
    function(nm) grepl(paste0("ConjointSD.", nm), text, fixed = TRUE),
    logical(1)
  )
  all_names[all_names != name & hits]
}

raw_deps <- setNames(lapply(theorems, function(nm) find_deps(nm, blocks[[nm]], theorems)), theorems)

# Transitive closure.
all_deps <- raw_deps
changed <- TRUE
while (changed) {
  changed <- FALSE
  for (nm in theorems) {
    deps <- unique(unlist(all_deps[nm]))
    expanded <- unique(c(deps, unlist(all_deps[deps])))
    if (!setequal(deps, expanded)) {
      all_deps[[nm]] <- expanded
      changed <- TRUE
    }
  }
}

# Structure block extraction.
structure_block_for <- function(name, lines) {
  start_pat <- paste0("^structure ConjointSD\\.", name, "\\.")
  idx <- grep(start_pat, lines)
  if (length(idx) == 0) return(character(0))
  start <- idx[1]
  next_idx <- grep("^(theorem|structure) ConjointSD\\.", lines[(start + 1):length(lines)])
  end <- if (length(next_idx) == 0) length(lines) else start + next_idx[1] - 1
  lines[start:end]
}

structure_blocks <- setNames(lapply(structures, structure_block_for, lines = lines), structures)

parse_structure <- function(struct_name, block) {
  field_lines <- block[grepl("^  ConjointSD\\.", block)]
  if (length(field_lines) == 0) {
    return(list(fields = character(0), nested = character(0)))
  }
  field_name <- sub("^  ConjointSD\\.[^.]+\\.([^ ]+) :.*$", "\\1", field_lines)
  field_type <- sub("^  ConjointSD\\.[^.]+\\.[^ ]+ : (.*)$", "\\1", field_lines)
  nested <- unique(unlist(regmatches(field_type, gregexpr("ConjointSD\\.[A-Za-z0-9_]+", field_type))))
  nested <- sub("^ConjointSD\\.", "", nested)
  primitive <- !grepl("ConjointSD\\.", field_type)
  list(fields = field_name[primitive], nested = nested)
}

structure_info <- setNames(lapply(structures, function(s) parse_structure(s, structure_blocks[[s]])), structures)

structure_field_assumptions <- unique(unlist(lapply(names(structure_info), function(s) {
  fields <- structure_info[[s]]$fields
  if (length(fields) == 0) return(character(0))
  paste(s, fields)
})))

structure_nested <- lapply(structure_info, function(info) info$nested)

structure_closure <- function(struct_name, nested_map) {
  seen <- character(0)
  stack <- struct_name
  while (length(stack) > 0) {
    current <- stack[[1]]
    stack <- stack[-1]
    if (current %in% seen) next
    seen <- c(seen, current)
    if (!is.null(nested_map[[current]])) {
      stack <- c(stack, nested_map[[current]])
    }
  }
  seen
}

extra_patterns <- c(
  "MeasureTheory.IsProbabilityMeasure μ" = "IsProbabilityMeasure μ",
  "MeasureTheory.IsProbabilityMeasure ν" = "IsProbabilityMeasure ν",
  "MeasureTheory.Measure.map (A 0) μ = ν" = "Measure map (A 0) μ = ν",
  "Measurable (A 0)" = "Measurable (A 0)",
  "ConjointSD.InvarianceAE" = "InvarianceAE",
  "ConjointSD.WellSpecified" = "WellSpecified",
  "Filter.Tendsto θhat" = "Tendsto θhat -> θ0",
  "βOf θ0 = β" = "betaOf θ0 = beta",
  "βOf θ0 = β0" = "betaOf θ0 = beta",
  "0 < ε" = "Epsilon > 0",
  "∀ᵐ (a : Attr) ∂ν, s a = t a" = "AE equality s = t under ν"
)

assumptions <- unique(c(structure_field_assumptions, unname(extra_patterns)))

assumptions_in_block <- function(block, name) {
  text <- paste(block, collapse = "\n")
  hit <- setNames(rep(FALSE, length(assumptions)), assumptions)

  for (s in structures) {
    if (grepl(paste0("ConjointSD.", s), text, fixed = TRUE)) {
      for (s_hit in structure_closure(s, structure_nested)) {
        fields <- structure_info[[s_hit]]$fields
        if (length(fields) > 0) {
          hit[paste(s_hit, fields)] <- TRUE
        }
      }
    }
  }

  for (pat in names(extra_patterns)) {
    if (grepl(pat, text, fixed = TRUE)) hit[[extra_patterns[[pat]]]] <- TRUE
  }

  hit
}

assumption_direct <- setNames(lapply(theorems, function(nm) assumptions_in_block(blocks[[nm]], nm)), theorems)

# Make assumptions transitive along theorem dependencies.
assumption_all <- assumption_direct
for (nm in theorems) {
  deps <- all_deps[[nm]]
  if (length(deps) > 0) {
    trans <- Reduce(`|`, lapply(deps, function(d) assumption_all[[d]]), init = assumption_all[[nm]])
    assumption_all[[nm]] <- trans
  }
}

sym_yes <- "✅"
sym_no <- "❌"

pretty_name <- function(x) gsub("_", " ", x, fixed = TRUE)

fmt_matrix <- function(mat, diag_omit = FALSE) {
  out <- mat
  for (i in seq_len(nrow(out))) {
    for (j in seq_len(ncol(out))) {
      if (diag_omit && i == j) {
        out[i, j] <- "Ø"
      } else {
        out[i, j] <- if (out[i, j]) sym_yes else sym_no
      }
    }
  }
  out
}

# Assumption matrix (rows = assumptions, cols = theorems).
assump_mat <- matrix(FALSE, nrow = length(assumptions), ncol = length(theorems),
                     dimnames = list(assumptions, theorems))
for (j in seq_along(theorems)) {
  assump_mat[, j] <- as.logical(assumption_all[[theorems[j]]])
}

dimnames(assump_mat) <- list(pretty_name(rownames(assump_mat)), pretty_name(colnames(assump_mat)))
assump_fmt <- fmt_matrix(assump_mat)

# Theorem dependency matrix (rows = theorems, cols = theorems).

dep_mat <- matrix(FALSE, nrow = length(theorems), ncol = length(theorems),
                  dimnames = list(theorems, theorems))
for (j in seq_along(theorems)) {
  col_name <- theorems[j]
  dep_mat[, j] <- theorems %in% all_deps[[col_name]]
}

dimnames(dep_mat) <- list(pretty_name(rownames(dep_mat)), pretty_name(colnames(dep_mat)))
dep_fmt <- fmt_matrix(dep_mat, diag_omit = TRUE)
```

## Auto-generated assumption matrix

```{r assumption-table, echo=FALSE}
knitr::kable(assump_fmt, align = "l")
```

## Auto-generated theorem dependency matrix

```{r dependency-table, echo=FALSE}
knitr::kable(dep_fmt, align = "l")
```
