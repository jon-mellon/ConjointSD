---
title: "Dependency Tables"
output: md_document
---

This document auto-generates theorem dependency tables by parsing the output of
`Scratch.lean`.

```{r setup, echo=FALSE}
options(width = 120)
```

```{r collect, echo=FALSE}
cmd <- "lake env lean Scratch.lean"
lines <- system(cmd, intern = TRUE)

# Theorems printed from Scratch.lean.
theorem_lines <- lines[grepl("^theorem ConjointSD\\.", lines)]
theorems <- unique(sub("^theorem ConjointSD\\.([^.{ ]+).*$", "\\1", theorem_lines))
theorems <- theorems[theorems != ""]

# Expand by printing every ConjointSD reference seen in Scratch output.
refs <- unique(unlist(regmatches(lines, gregexpr("ConjointSD\\.[A-Za-z0-9_]+", lines))))
refs <- unique(sub("^ConjointSD\\.", "", refs))

run_prints <- function(names) {
  tmp_lean <- tempfile(fileext = ".lean")
  writeLines(c("import ConjointSD", paste0("#print ConjointSD.", sort(names))), tmp_lean)
  output <- suppressWarnings(
    system2("lake", c("env", "lean", tmp_lean), stdout = TRUE, stderr = TRUE)
  )
  unknown <- unique(c(
    unlist(regmatches(output, gregexpr("unknown constant 'ConjointSD\\.[A-Za-z0-9_]+'", output))),
    unlist(regmatches(output, gregexpr("Unknown constant `ConjointSD\\.[A-Za-z0-9_]+`", output)))
  ))
  unknown <- gsub("unknown constant 'ConjointSD\\.", "", unknown, ignore.case = TRUE)
  unknown <- gsub("Unknown constant `ConjointSD\\.", "", unknown, ignore.case = TRUE)
  unknown <- gsub("[`']$", "", unknown)
  list(output = output, unknown = unknown)
}

refs_known <- refs
lines_all <- character(0)
repeat {
  res <- run_prints(refs_known)
  if (length(res$unknown) == 0) {
    lines_all <- res$output
    break
  }
  next_refs <- setdiff(refs_known, res$unknown)
  if (length(next_refs) == length(refs_known)) {
    lines_all <- res$output
    break
  }
  refs_known <- next_refs
}

if (length(lines_all) == 0) {
  lines_all <- lines
}

# Structures printed from Scratch.lean (for assumption field names).
structure_lines <- lines_all[grepl("^structure ConjointSD\\.", lines_all)]
structures <- unique(sub("^structure ConjointSD\\.([^.{ ]+).*$", "\\1", structure_lines))
structures <- structures[structures != ""]

# Definitions printed from Scratch.lean (for non-structure assumptions).
def_lines <- lines_all[grepl("^def ConjointSD\\.", lines_all)]
defs <- unique(sub("^def ConjointSD\\.([^.{ ]+).*$", "\\1", def_lines))
defs <- defs[defs != ""]

# Extract #print blocks for each theorem.
block_for <- function(name, lines) {
  start_pat <- paste0("^theorem ConjointSD\\.", name, "\\.")
  idx <- grep(start_pat, lines)
  if (length(idx) == 0) return(character(0))
  start <- idx[1]
  # End at next theorem/structure print or end of file.
  next_idx <- grep("^(theorem|structure) ConjointSD\\.", lines[(start + 1):length(lines)])
  end <- if (length(next_idx) == 0) length(lines) else start + next_idx[1] - 1
  lines[start:end]
}

all_names <- unique(c(theorems, refs))
blocks <- setNames(lapply(all_names, block_for, lines = lines_all), all_names)

# Dependency graph: if a block references another theorem name, count it as a dependency.
find_deps <- function(name, block, all_names) {
  if (length(block) == 0) return(character(0))
  text <- paste(block, collapse = "\n")
  hits <- vapply(
    all_names,
    function(nm) grepl(paste0("ConjointSD.", nm), text, fixed = TRUE),
    logical(1)
  )
  all_names[all_names != name & hits]
}

raw_deps <- setNames(lapply(all_names, function(nm) find_deps(nm, blocks[[nm]], all_names)), all_names)

# Transitive closure.
all_deps <- raw_deps
changed <- TRUE
while (changed) {
  changed <- FALSE
  for (nm in theorems) {
    deps <- unique(unlist(all_deps[nm]))
    expanded <- unique(c(deps, unlist(all_deps[deps])))
    if (!setequal(deps, expanded)) {
      all_deps[[nm]] <- expanded
      changed <- TRUE
    }
  }
}

# Structure block extraction.
structure_block_for <- function(name, lines) {
  start_pat <- paste0("^structure ConjointSD\\.", name, "\\.")
  idx <- grep(start_pat, lines)
  if (length(idx) == 0) return(character(0))
  start <- idx[1]
  next_idx <- grep("^(theorem|structure) ConjointSD\\.", lines[(start + 1):length(lines)])
  end <- if (length(next_idx) == 0) length(lines) else start + next_idx[1] - 1
  lines[start:end]
}

structure_blocks <- setNames(lapply(structures, structure_block_for, lines = lines_all), structures)

parse_structure <- function(struct_name, block) {
  field_lines <- block[grepl("^  ConjointSD\\.", block)]
  if (length(field_lines) == 0) {
    return(list(fields = character(0), nested = character(0)))
  }
  field_name <- sub("^  ConjointSD\\.[^.]+\\.([^ ]+) :.*$", "\\1", field_lines)
  field_type <- sub("^  ConjointSD\\.[^.]+\\.[^ ]+ : (.*)$", "\\1", field_lines)
  nested <- unique(unlist(regmatches(field_type, gregexpr("ConjointSD\\.[A-Za-z0-9_]+", field_type))))
  nested <- sub("^ConjointSD\\.", "", nested)
  primitive <- !grepl("ConjointSD\\.", field_type)
  list(fields = field_name[primitive], nested = nested)
}

structure_info <- setNames(lapply(structures, function(s) parse_structure(s, structure_blocks[[s]])), structures)

def_block_for <- function(name, lines) {
  start_pat <- paste0("^def ConjointSD\\.", name, "([ .])")
  idx <- grep(start_pat, lines)
  if (length(idx) == 0) return(character(0))
  start <- idx[1]
  next_idx <- grep("^(theorem|structure|def) ConjointSD\\.", lines[(start + 1):length(lines)])
  end <- if (length(next_idx) == 0) length(lines) else start + next_idx[1] - 1
  lines[start:end]
}

def_blocks <- setNames(lapply(defs, def_block_for, lines = lines_all), defs)
def_is_prop <- vapply(defs, function(nm) {
  blk <- def_blocks[[nm]]
  if (length(blk) == 0) return(FALSE)
  header <- paste(blk[1:min(2, length(blk))], collapse = " ")
  grepl(": Prop", header, fixed = TRUE)
}, logical(1))
assumption_defs <- defs[def_is_prop]

assumptions_text <- readLines("ConjointSD/Assumptions.lean", warn = FALSE)
assump_def_names <- sub("^\\s*def\\s+([A-Za-z0-9_\\.]+)\\b.*$", "\\1",
                        grep("^\\s*def\\s+[A-Za-z0-9_\\.]+\\b", assumptions_text, value = TRUE))
assump_def_names <- assump_def_names[nzchar(assump_def_names)]
assump_prop_defs <- character(0)
if (length(assump_def_names) > 0) {
  for (nm in assump_def_names) {
    idx <- grep(paste0("^\\s*def\\s+", nm, "\\b"), assumptions_text)
    if (length(idx) == 0) next
    start <- idx[1]
    end <- length(assumptions_text)
    next_idx <- grep("^\\s*(def|structure|theorem|lemma)\\s", assumptions_text[(start + 1):length(assumptions_text)])
    if (length(next_idx) > 0) end <- start + next_idx[1] - 1
    block <- paste(assumptions_text[start:end], collapse = " ")
    if (grepl(":\\s*Prop\\b", block, perl = TRUE)) assump_prop_defs <- c(assump_prop_defs, nm)
  }
}
assumption_defs <- sort(unique(c(assumption_defs, assump_prop_defs)))

structure_field_assumptions <- unique(unlist(lapply(names(structure_info), function(s) {
  fields <- structure_info[[s]]$fields
  if (length(fields) == 0) return(character(0))
  paste(s, fields)
})))

structure_nested <- lapply(structure_info, function(info) info$nested)

structure_closure <- function(struct_name, nested_map) {
  seen <- character(0)
  stack <- struct_name
  while (length(stack) > 0) {
    current <- stack[[1]]
    stack <- stack[-1]
    if (current %in% seen) next
    seen <- c(seen, current)
    if (!is.null(nested_map[[current]])) {
      stack <- c(stack, nested_map[[current]])
    }
  }
  seen
}

extract_atomic_assumptions <- function(text) {
  labels <- character(0)
  text_flat <- gsub("\n", " ", text)

  ip <- unlist(regmatches(text_flat, gregexpr("MeasureTheory.IsProbabilityMeasure [A-Za-z0-9_]+", text_flat)))
  if (length(ip) > 0) {
    labels <- c(labels, gsub("MeasureTheory.IsProbabilityMeasure ", "IsProbabilityMeasure ", ip))
  }

  meas <- unlist(regmatches(text_flat, gregexpr("Measurable \\(A 0\\)", text_flat)))
  if (length(meas) > 0) labels <- c(labels, meas)

  maps <- unlist(regmatches(text_flat, gregexpr("MeasureTheory.Measure.map \\(A 0\\) [A-Za-z0-9_]+ = [A-Za-z0-9_]+", text_flat)))
  if (length(maps) > 0) {
    labels <- c(labels, gsub("MeasureTheory.Measure.map ", "Measure map ", maps))
  }

  tendsto <- unlist(regmatches(text_flat, gregexpr("Filter.Tendsto θhat[^,)]*\\(nhds [A-Za-z0-9_]+\\)", text_flat)))
  if (length(tendsto) > 0) labels <- c(labels, tendsto)

  beta_eq <- unlist(regmatches(text_flat, gregexpr("βOf θ0 = [A-Za-z0-9_]+", text_flat)))
  if (length(beta_eq) > 0) labels <- c(labels, beta_eq)

  eps <- unlist(regmatches(text_flat, gregexpr("0 < [A-Za-z0-9_]+", text_flat)))
  if (length(eps) > 0) labels <- c(labels, eps)

  ae_eq <- unlist(regmatches(text_flat, gregexpr("∀ᵐ \\(a : Attr\\) ∂ν, s a = t a", text_flat)))
  if (length(ae_eq) > 0) labels <- c(labels, ae_eq)

  labels
}

assumption_defs_in_block <- function(text) {
  hits <- character(0)
  for (nm in assumption_defs) {
    if (grepl(paste0("ConjointSD.", nm), text, fixed = TRUE)) hits <- c(hits, nm)
  }
  hits
}

assumptions_in_block <- function(block) {
  text <- paste(block, collapse = "\n")
  hit <- character(0)

  for (s in structures) {
    if (grepl(paste0("ConjointSD.", s), text, fixed = TRUE)) {
      for (s_hit in structure_closure(s, structure_nested)) {
        fields <- structure_info[[s_hit]]$fields
        if (length(fields) > 0) {
          hit <- c(hit, paste(s_hit, fields))
        }
      }
    }
  }

  hit <- c(hit, assumption_defs_in_block(text))
  unique(hit)
}

assumption_direct <- setNames(lapply(all_names, function(nm) assumptions_in_block(blocks[[nm]])), all_names)

assumptions <- sort(unique(c(structure_field_assumptions, unlist(assumption_direct))))

# Make assumptions transitive along theorem dependencies.
assumption_all <- lapply(assumption_direct, function(x) {
  setNames(assumptions %in% x, assumptions)
})
for (nm in all_names) {
  deps <- all_deps[[nm]]
  if (length(deps) > 0) {
    trans <- Reduce(`|`, lapply(deps, function(d) assumption_all[[d]]), init = assumption_all[[nm]])
    assumption_all[[nm]] <- trans
  }
}

sym_yes <- "✅"
sym_no <- "❌"

pretty_name <- function(x) gsub("_", " ", x, fixed = TRUE)

fmt_matrix <- function(mat, diag_omit = FALSE) {
  out <- mat
  for (i in seq_len(nrow(out))) {
    for (j in seq_len(ncol(out))) {
      if (diag_omit && i == j) {
        out[i, j] <- "Ø"
      } else {
        out[i, j] <- if (out[i, j]) sym_yes else sym_no
      }
    }
  }
  out
}

# Assumption matrix (rows = assumptions, cols = theorems).
assump_mat <- matrix(FALSE, nrow = length(assumptions), ncol = length(theorems),
                     dimnames = list(assumptions, theorems))
for (j in seq_along(theorems)) {
  assump_mat[, j] <- as.logical(assumption_all[[theorems[j]]])
}

dimnames(assump_mat) <- list(pretty_name(rownames(assump_mat)), pretty_name(colnames(assump_mat)))
assump_fmt <- fmt_matrix(assump_mat)
assump_count <- rowSums(assump_mat)

# Theorem dependency matrix (rows = theorems, cols = theorems).

dep_mat <- matrix(FALSE, nrow = length(theorems), ncol = length(theorems),
                  dimnames = list(theorems, theorems))
for (j in seq_along(theorems)) {
  col_name <- theorems[j]
  dep_mat[, j] <- theorems %in% all_deps[[col_name]]
}

dimnames(dep_mat) <- list(pretty_name(rownames(dep_mat)), pretty_name(colnames(dep_mat)))
dep_fmt <- fmt_matrix(dep_mat, diag_omit = TRUE)
```

## Auto-generated assumption matrix

```{r assumption-table, echo=FALSE}
knitr::kable(cbind(Count = assump_count, assump_fmt), align = "l")
```

```{r assumption-xlsx, echo=FALSE}
assump_tbl <- data.frame(
  Assumption = rownames(assump_fmt),
  Count = assump_count,
  assump_fmt,
  check.names = FALSE
)

out_dir <- "dependency_tables_files"
if (!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE)
out_xlsx <- file.path(out_dir, "assumption_matrix.xlsx")

if (requireNamespace("writexl", quietly = TRUE)) {
  writexl::write_xlsx(assump_tbl, out_xlsx)
} else if (requireNamespace("openxlsx", quietly = TRUE)) {
  openxlsx::write.xlsx(assump_tbl, out_xlsx, overwrite = TRUE)
} else {
  out_csv <- file.path(out_dir, "assumption_matrix.csv")
  write.csv(assump_tbl, out_csv, row.names = FALSE)
  warning("Package 'writexl' or 'openxlsx' is required to write assumption_matrix.xlsx; wrote CSV instead.")
}
```

## Theorem dependency DAG

```{r dependency-dag, echo=FALSE, fig.width=10, fig.height=8}
if (!requireNamespace("DiagrammeR", quietly = TRUE) ||
    !requireNamespace("DiagrammeRsvg", quietly = TRUE) ||
    !requireNamespace("rsvg", quietly = TRUE)) {
  stop("Packages 'DiagrammeR', 'DiagrammeRsvg', and 'rsvg' are required to plot the dependency DAG.")
}

edge_rows <- lapply(theorems, function(thm) {
  deps <- intersect(raw_deps[[thm]], theorems)
  if (length(deps) == 0) return(NULL)
  data.frame(from = deps, to = thm, stringsAsFactors = FALSE)
})
edges <- do.call(rbind, edge_rows)

if (is.null(edges) || nrow(edges) == 0) {
  plot.new()
  text(0.5, 0.5, "No theorem dependencies found.")
} else {
  labels <- vapply(
    theorems,
    function(nm) paste(strwrap(pretty_name(nm), width = 18), collapse = "\\n"),
    character(1)
  )
  sinks <- setdiff(theorems, unique(edges$from))
  nodes <- data.frame(name = theorems, label = labels, stringsAsFactors = FALSE)
  node_lines <- vapply(
    seq_len(nrow(nodes)),
    function(i) {
      fill <- if (nodes$name[i] %in% sinks) "#f2a5a5" else "#F7F7F7"
      sprintf('"%s" [label="%s", fillcolor="%s"];', nodes$name[i], nodes$label[i], fill)
    },
    character(1)
  )
  edge_lines <- sprintf('"%s" -> "%s";', edges$from, edges$to)
  dot <- sprintf(
    'digraph G {
      graph [rankdir=TB, labelloc="t", fontsize=18, nodesep=0.35, ranksep=0.5];
      node  [shape=box, style="rounded,filled", fillcolor="#F7F7F7", color="#444444", fontname="Helvetica"];
      edge  [color="#666666", arrowsize=0.5];

      %s

      %s
    }',
    paste(node_lines, collapse = "\n"),
    paste(edge_lines, collapse = "\n")
  )
  graph <- DiagrammeR::grViz(dot)
  svg <- DiagrammeRsvg::export_svg(graph)
  out_dir <- "dependency_tables_files"
  if (!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE)
  out_png <- file.path(out_dir, "theorem_dependency_dag.png")
  rsvg::rsvg_png(charToRaw(svg), file = out_png)
  knitr::include_graphics(out_png)
}
```

## OLS SD consistency DAG (direct assumptions)

```{r ols-sd-consistency-dag, echo=FALSE, fig.width=10, fig.height=8}
if (!requireNamespace("DiagrammeR", quietly = TRUE) ||
    !requireNamespace("DiagrammeRsvg", quietly = TRUE) ||
    !requireNamespace("rsvg", quietly = TRUE)) {
  stop("Packages 'DiagrammeR', 'DiagrammeRsvg', and 'rsvg' are required to plot the dependency DAG.")
}

ols_sd_core <- c(
  "paper_sd_total_sequential_consistency_to_true_target_ae_of_paper_ols_design_ae_of_NoInteractions_of_randomization",
  "paper_sd_total_sequential_consistency_to_true_target_ae",
  "paper_sd_total_sequential_consistency_ae_of_hGTotal",
  "theta_tendsto_of_paper_ols_design_ae",
  "theta_tendsto_of_paper_ols_moments",
  "theta_tendsto_of_paper_ols_moments_ae",
  "paper_ols_attr_moments_of_design_ae",
  "paper_ols_gramInv_tendsto_of_design_ae",
  "olsThetaHat_tendsto_of_attr_moments",
  "olsThetaHat_tendsto_of_moment_assumptions_id",
  "olsThetaHat_tendsto_of_moment_assumptions",
  "paper_ols_normal_eq_of_wellSpecified",
  "paper_ols_theta0_eq_of_normal_eq",
  "gStar_eq_sum_blocks_of_WellSpecified",
  "wellSpecified_of_noInteractions_of_fullMainEffects"
)
ols_sd_core <- ols_sd_core[ols_sd_core %in% all_names]
target_thm <- "paper_sd_total_sequential_consistency_to_true_target_ae_of_paper_ols_design_ae_of_NoInteractions_of_randomization"
if (!(target_thm %in% ols_sd_core)) target_thm <- ols_sd_core[[1]]
chain_nodes <- unique(c(target_thm, all_deps[[target_thm]]))
chain_nodes <- chain_nodes[chain_nodes %in% ols_sd_core]

dot_escape <- function(x) {
  x <- gsub("\\\\", "\\\\\\\\", x)
  gsub("\"", "\\\\\"", x)
}

edge_rows <- lapply(chain_nodes, function(thm) {
  deps <- intersect(raw_deps[[thm]], chain_nodes)
  if (length(deps) == 0) return(NULL)
  data.frame(from = deps, to = thm, stringsAsFactors = FALSE)
})
edges <- do.call(rbind, edge_rows)

assump_edges <- lapply(chain_nodes, function(thm) {
  block <- blocks[[thm]]
  if (length(block) == 0) return(NULL)
  text <- paste(block, collapse = "\n")
  assumps <- character(0)
  for (s in structures) {
    if (grepl(paste0("ConjointSD.", s), text, fixed = TRUE)) {
      for (s_hit in structure_closure(s, structure_nested)) {
        fields <- structure_info[[s_hit]]$fields
        if (length(fields) > 0) {
          assumps <- c(assumps, paste(s_hit, fields))
        }
      }
    }
  }
  for (nm in assumption_defs) {
    if (grepl(paste0("ConjointSD.", nm), text, fixed = TRUE)) assumps <- c(assumps, nm)
  }
  assumps <- unique(assumps)
  if (length(assumps) == 0) return(NULL)
  data.frame(from = assumps, to = thm, stringsAsFactors = FALSE)
})
assump_edges <- do.call(rbind, assump_edges)

assump_nodes <- character(0)
if (!is.null(assump_edges) && nrow(assump_edges) > 0) {
  assump_nodes <- sort(unique(assump_edges$from))
}

if ((is.null(edges) || nrow(edges) == 0) && length(assump_nodes) == 0) {
  plot.new()
  text(0.5, 0.5, "No OLS SD dependencies found.")
} else {
  pretty_core <- setNames(vapply(chain_nodes, pretty_name, character(1)), chain_nodes)
  core_labels <- vapply(
    chain_nodes,
    function(nm) pretty_core[[nm]],
    character(1)
  )
  core_nodes <- data.frame(
    name = dot_escape(chain_nodes),
    label = dot_escape(core_labels),
    stringsAsFactors = FALSE
  )

  assump_labels <- vapply(
    assump_nodes,
    function(nm) nm,
    character(1)
  )
  assump_nodes_df <- data.frame(
    name = dot_escape(assump_nodes),
    label = dot_escape(assump_labels),
    stringsAsFactors = FALSE
  )

  final_node <- target_thm
  node_lines <- c(
    vapply(
      seq_len(nrow(core_nodes)),
      function(i) {
        fill <- if (core_nodes$name[i] == dot_escape(final_node)) "#f2a5a5" else "#F7F7F7"
        sprintf('"%s" [label="%s", fillcolor="%s"];', core_nodes$name[i], core_nodes$label[i], fill)
      },
      character(1)
    ),
    vapply(
      seq_len(nrow(assump_nodes_df)),
      function(i) {
        sprintf('"%s" [label="%s", fillcolor="#8CC5FF"];', assump_nodes_df$name[i], assump_nodes_df$label[i])
      },
      character(1)
    )
  )

  edge_lines <- character(0)
  if (!is.null(edges) && nrow(edges) > 0) {
    edge_lines <- c(
      edge_lines,
      sprintf('"%s" -> "%s";', dot_escape(edges$from), dot_escape(edges$to))
    )
  }
  if (!is.null(assump_edges) && nrow(assump_edges) > 0) {
    edge_lines <- c(
      edge_lines,
      sprintf('"%s" -> "%s";', dot_escape(assump_edges$from), dot_escape(assump_edges$to))
    )
  }

  dot <- sprintf(
    'digraph G {
      graph [rankdir=LR, labelloc="t", fontsize=16, nodesep=0.15, ranksep=0.35];
      node  [shape=box, style="rounded,filled", fillcolor="#F7F7F7", color="#444444", fontname="Helvetica", fontsize=10];
      edge  [color="#666666", arrowsize=0.5];

      %s

      %s
    }',
    paste(node_lines, collapse = "\n"),
    paste(edge_lines, collapse = "\n")
  )
  graph <- DiagrammeR::grViz(dot)
  svg <- DiagrammeRsvg::export_svg(graph)
  out_dir <- "dependency_tables_files"
  if (!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE)
  out_png <- file.path(out_dir, "ols_sd_consistency_dag.png")
  rsvg::rsvg_png(charToRaw(svg), file = out_png)
  knitr::include_graphics(out_png)
}
```
